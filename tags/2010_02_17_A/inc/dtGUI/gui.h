/* 
 * Delta3D Open Source Game and Simulation Engine 
 * Copyright (C) 2010 MOVES Institute 
 *
 * This library is free software; you can redistribute it and/or modify it under
 * the terms of the GNU Lesser General Public License as published by the Free 
 * Software Foundation; either version 2.1 of the License, or (at your option) 
 * any later version.
 *
 * This library is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS 
 * FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more 
 * details.
 *
 * You should have received a copy of the GNU Lesser General Public License 
 * along with this library; if not, write to the Free Software Foundation, Inc., 
 * 59 Temple Place, Suite 330, Boston, MA 02111-1307 USA 
 *
 */
#ifndef GUI_h__
#define GUI_h__

#include <dtGUI/export.h>
#include <dtCore/base.h>
#include <dtCore/refptr.h>
#include <dtGUI/ceguimouselistener.h>
#include <dtGUI/ceguikeyboardlistener.h>
#include <dtGUI/widget.h>
#include <CEGUI/CEGUIEvent.h>

/// @cond DOXYGEN_SHOULD_SKIP_THIS
namespace osg
{
   class Geode;
   class Camera;
}
/// @endcond

namespace dtCore
{
   class Camera;
   class Keyboard;
   class Mouse;
}

namespace dtGUI
{
   /** 
    * Used for rendering and managing on-screen, graphical user interfaces.
    */
   class DT_GUI_EXPORT GUI : public dtCore::Base
   {
   public:
      DECLARE_MANAGEMENT_LAYER(GUI)

      /** 
       * Create the GUI instance.
       * @param pTargetCamera The Camera the UI will be rendered to
       * @param pObservedKeyboard The Keyboard to listen to for events
       * @param pObservedMouse The Mouse to listen to for events
       */
      GUI(dtCore::Camera* pTargetCamera,
          dtCore::Keyboard* pObservedKeyboard = NULL,
          dtCore::Mouse* pObservedMouse = NULL);

      /** 
       * Sets the Camera to use for rendering to
       * @param pTargetCamera If NULL, no GUI rendering will take place
       */
      void SetCamera(dtCore::Camera* pTargetCamera);

      /** 
       *  Set the Mouse from which the gui receives events
       *  @param pObservedMouse If NULL, no Mouse events will be read
       */
      void SetMouse(dtCore::Mouse* pObservedMouse);

      /** 
       *  Set the Keyboard from which the GUI receives events.
       *  @param pObservedMouse If NULL, no Keyboard events will be read
       */
      void SetKeyboard(dtCore::Keyboard* pObservedKeyboard);

      ///returns default sheet (autogenerated root-window)
      Widget* GetRootSheet() { return m_pRootsheet; }

      ///returns default sheet (autogenerated root-window)
      const Widget* GetRootSheet() const { return m_pRootsheet; }

      /** 
       * Load a Layout file
       * @param sFileName The filename of the .layout file
       * @param sPrefix Optional string prefix that is to be used when creating 
       *        the windows in the layout file, this function allows a layout to be
       *        loaded multiple times without having name clashes.
       * @param sResourceGroup Optional string of the resource group this layout belongs to
       * @return The root Widget loaded from the .layout
       */
      Widget* LoadLayout(const std::string& sFileName, 
                         const std::string& sPrefix="",
                         const std::string& sResourceGroup = "");

     /** 
       * Load a Layout file and automatically add the loaded root Widget to the supplied parent widget
       * @param pWidgetParent The parent widget to add the loaded layout to
       * @param sFileName The filename of the .layout file
       * @param sPrefix Optional string prefix that is to be used when creating 
       *        the windows in the layout file, this function allows a layout to be
       *        loaded multiple times without having name clashes.
       * @param sResourceGroup Optional string of the resource group this layout belongs to
       * @return The root Widget loaded from the .layout
       */
      Widget* LoadLayout(Widget* pWidgetParent, const std::string& sFileName, 
                         const std::string& sPrefix="", const std::string& sResourceGroup = "");

      /** 
        * Create a Widget and add it to the internal root Widget
        * @param sWidgetTypeName The type of widget to create (e.g., "WindowsLook/FrameWindow")
        * @param sWidgetName The name to apply to the widget
        * @return The created Widget (could be NULL if an error occurred)
        */
      Widget* CreateWidget(const std::string& sWidgetTypeName, const std::string& sWidgetName="");

      /** 
        * Create a Widget and add it to the supplied parent Widget.
        * @param pWidgetParent The parent widget to add newly created widget to
        * @param sWidgetTypeName The type of widget to create (e.g., "WindowsLook/FrameWindow")
        * @param sWidgetName The name to apply to the widget
        * @return The created Widget (could be NULL if an error occurred)
        */
      Widget* CreateWidget(Widget* pParentWidget, const std::string& sWidgetTypeName, const std::string& sWidgetName="");

      /** 
        * Find and return the widget by widget name.
        * @param sWidgetName the name of the widget to find
        * @return The found widget (or NULL, if not found)
        */
      Widget* GetWidget(const std::string& sWidgetName);

      /** 
        * Set the directory for the supplied resource type.
        * @code
        * dtGUI::GUI::SetResourceGroupDirectory("layouts", "c:\temp\layouts");
        * @endcode
        * @param resourceType The type of resource to set the directory for.  Could be
        * "imagesets", "looknfeels", "layouts", "lua_scripts", "schemes", or "fonts"
        * @param directory The directory containing the resource types
        */
      static void SetResourceGroupDirectory(const std::string& resourceType, const std::string& directory);

      typedef CEGUI::Event::Subscriber Subscriber;

      /** 
        * Subscribe a callback to the supplied widget's event.  
        * @param widgetName The name of an existing widget
        * @param event The name of an event generated by the widget
        * @param subscriber The callback functor to receive the event
        * @return The Connection object, used this to manage the connection
        */
      CEGUI::Event::Connection SubscribeEvent(const std::string& widgetName, 
                                              const std::string& event,
                                              GUI::Subscriber subscriber);

      /** 
        * Subscribe a callback to the supplied widget's event.  
        * @param widget An existing widget 
        * @param event The name of an event generated by the widget
        * @param subscriber The callback functor to receive the event
        * @return The Connection object, used this to manage the connection
        */
      CEGUI::Event::Connection SubscribeEvent(Widget& widget, 
                                              const std::string& event, 
                                              GUI::Subscriber subscriber);

      /** 
        * Is the supplied widget present in the system?
        * @param sWindowName The name of widget
        * @return true if the widget exists, false otherwise
        */
      static bool IsWindowPresent(const std::string& sWindowName);

      /** 
        * Is the supplied Imageset present in the system?
        * @param sImagesetName The name of ImageSet
        * @return true if the ImageSet exists, false otherwise
        */
      static bool IsImagesetPresent(const std::string& sImagesetName);

      /** 
        * Create an ImageSet based on the supplied Image file. The Imageset will 
        * initially have a single image defined named "full_image" which is an image 
        * that represents the entire area of the loaded image. 
        * @param sImagesetName 
        * @param sFileName The name of the Image file to load
        * @param sResourceGroup Optional resource group this imageset belongs to
        */
      static void CreateImageset(const std::string& sImagesetName,
                                 const std::string& sFileName,
                                 const std::string& sResourceGroup = "");

      /* 
       * Shortcut to the CEGUI::SchemeManager
       * @param sFileName The filename of the .scheme file to load
       * @param sResourceGroup The name of the optional resource group this belongs to
       */
      static void LoadScheme(const std::string& sFileName, const std::string& sResourceGroup = "");

      /* 
       * Set the image for the rendered mouse cursor.
       * @param sImagesetName The ImageSet name
       * @param sImageName The name of the Image defined in the ImageSet
       */
      static void SetMouseCursor(const std::string& sImagesetName, const std::string& sImageName);

   protected:
      virtual ~GUI();
   	
   private:
      void _SetupInternalGraph();
      void _SetupDefaultUI();

      ///used to receive "preframe"-delta-messages
      void OnMessage(dtCore::Base::MessageData *data);

      static void _SetupSystemAndRenderer();
      static bool SystemAndRendererCreatedByHUD;

      dtCore::RefPtr<dtGUI::CEGUIKeyboardListener> m_pKeyboardListener; ///needed for injection mouse-events to the cegui
      dtCore::RefPtr<dtGUI::CEGUIMouseListener>    m_pMouseListener; ///needed for injection keyboard-events to the cegui
      osg::Geode*                                  m_pInternalGraph; ///osg graph used to render the gui
      CEGUI::Window*                        m_pRootsheet; ///auto-generated panel-window

      dtCore::RefPtr<osg::Camera>           m_pCamera; ///camera, whose viewport is used to draw the gui
      dtCore::RefPtr<dtCore::Keyboard>      m_pKeyboard; ///observed keyboard
      dtCore::RefPtr<dtCore::Mouse>         m_pMouse; ///observed mouse

   };
}
#endif // GUI_h__
