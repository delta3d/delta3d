import glob
import os 
import shutil
import re
import sys
import time
import smtplib
import string
import SCons.Util
import macosx
import SCons.Util
import platform
from SCons.Script.SConscript import SConsEnvironment

from email.MIMEText import MIMEText

# TODO:
# install headers, libs, to prefix
# fix dtCore/dtUtil auto-install
# doxygen
# make packaged release
# CVS support

########################
# Build error emailing #
########################

# set this to true to enable build emailing
email = 'false'

# fill this in with interested parties
peopleToEmail = []

# replcae with your local outgoing SMTP server
smtpServer = 'mysmtp@server.com'

SetOption('implicit_cache', 1)

# this is who the build email will come from
fromAddress = 'myaddress@company.com'

########################

def SGlob(pattern):
   path = string.replace(GetBuildPath('SConscript'),  'SConscript', '')

   result = []
   for i in glob.glob(path + pattern):
      result.append(string.replace(i, path, ''))

   return result 

########################

def _lang2suffix(lang):
   """
   Convert a language name to a suffix.
   When 'lang' is empty or None C is assumed.
   Returns a tuple (lang, suffix, None) when it works.
   For an unrecognized language returns (None, None, msg).
   Where:
      lang   = the unified language name
      suffix = the suffix, including the leading dot
      msg    = an error message
   """
   if not lang or lang in ["C", "c"]:
      return ("C", ".c", None)
   if lang in ["c++", "C++", "cpp", "CXX", "cxx"]:
      return ("C++", ".cpp", None)

   return None, None, "Unsupported language: %s" % lang

########################

def CheckFramework(context, frameworks, func_name = 'main', header = None, 
             extra_frameworks = None, extra_libs = None, 
             call = None, language = None, autoadd = 0):
   """
   Configure check for a C or C++ 'frameworks'.  Searches through
   the list of libraries, until one is found where the test succeeds.
   Tests if 'func_name' or 'call' exists in the library.  Note: if it exists
   in another library the test succeeds anyway!
   Optional 'header' can be defined to include a header file.  If not given a
   default prototype for 'func_name' is added.
   Optional 'extra_libs' is a list of library names to be added after
   'lib_name' in the build command.  To be used for libraries that 'lib_name'
   depends on.
   Optional 'call' replaces the call to 'func_name' in the test code.  It must
   consist of complete C statements, including a trailing ';'.
   There must either be a 'func_name' or a 'call' argument (or both).
   'language' should be 'C' or 'C++' and is used to select the compiler.
   Default is 'C'.
   Note that this uses the current value of compiler and linker flags, make
   sure $CFLAGS, $CPPFLAGS and $LIBS are set correctly.
   Returns an empty string for success, an error message for failure.
   """
   if not header:
      header = ""

   text = """
         %s """ % (header)

   # Add a function declaration if needed.
   if func_name and func_name != "main" and not header:
      text = text + """
            #ifdef __cplusplus
            extern "C"
            #endif
            char %s();""" % func_name

   # The actual test code.
   if not call:
      call = "%s();" % func_name
   text = text + """
         int
         main() {
         %s
         return 0;
         }
         \n\n""" % call

   i = string.find(call, "\n")
   if i > 0:
      calltext = call[:i] + ".."
   elif call[-1] == ';':
      calltext = call[:-1]
   else:
      calltext = call

   if not SCons.Util.is_List(frameworks):
      frameworks = [frameworks]


   oldFrameworks = context.env.get('FRAMEWORKS', []) + []
   oldLIBS = context.env.get('LIBS', []) + []

   for framework_name in frameworks:

      lang, suffix, msg = _lang2suffix(language)
      if msg:
         context.Message("Cannot check for framework %s: %s\n" % (framework_name, msg))
         return msg

      context.Message("Checking for %s in %s framework %s... "
                  % (calltext, lang, framework_name))
      
      if framework_name:
         l = [ '-framework',  framework_name ]
         
         if extra_libs:
            context.env.Append(LIBS=extra_libs)
            
         context.env.Append(FRAMEWORKS=[framework_name])
         if extra_frameworks != None:
            context.env.Append(FRAMEWORKS=extra_frameworks)

         sym = "HAVE_LIB" + framework_name
      else:
         sym = None

      ret = context.BuildProg(text, suffix)

      _YesNoResult(context, ret, sym, text)
      if ret or autoadd == 0:
         context.env.Replace(FRAMEWORKS = oldFrameworks)
      
      if oldLIBS != []:
         context.env.Replace(LIBS = oldLIBS)
     
   context.Result(not ret)
   return not ret

########################

def _YesNoResult(context, ret, key, text):
   """
   Handle the result of a test with a 'yes' or 'no' result.
   'ret' is the return value: empty if OK, error message when not.
   'key' is the name of the symbol to be defined (HAVE_foo).
   'text' is the source code of the program used for testing.
   """
   if key:
      _Have(context, key, not ret)
   if ret:
      context.Display("no\n")
      _LogFailed(context, text, ret)
   else:
      context.Display("yes\n")

########################

def _Have(context, key, have):
   """
   Store result of a test in context.havedict and context.headerfilename.
   'key' is a 'HAVE_abc' name.  It is turned into all CAPITALS and ':./' are
   replaced by an underscore.
   The value of 'have' can be:
   1     - Feature is defined, add '#define key'.
   0     - Feature is not defined, add '/* #undef key */'.
          Adding 'undef' is what autoconf does.  Not useful for the
          compiler, but it shows that the test was done.
   number - Feature is defined to this number '#define key have'.
          Doesn't work for 0 or 1, use a string then.
   string - Feature is defined to this string '#define key have'.
          Give 'have' as is should appear in the header file, include quotes
          when desired and escape special characters!
   """
   key_up = string.upper(key)
   key_up = string.replace(key_up, ':', '_')
   key_up = string.replace(key_up, '.', '_')
   key_up = string.replace(key_up, '/', '_')
   key_up = string.replace(key_up, ' ', '_')
   context.havedict[key_up] = have
   if context.headerfilename:
      f = open(context.headerfilename, "a")
      if have == 1:
         f.write("#define %s\n" % key_up)
      elif have == 0:
         f.write("/* #undef %s */\n" % key_up)
      elif type(have) == IntType:
         f.write("#define %s %d\n" % (key_up, have))
      else:
         f.write("#define %s %s\n" % (key_up, str(have)))
      f.close()

########################

def _LogFailed(context, text, msg):
   """
   Write to the log about a failed program.
   Add line numbers, so that error messages can be understood.
   """
   context.Log("Failed program was:\n")
   lines = string.split(text, '\n')
   if len(lines) and lines[-1] == '':
      lines = lines[:-1]           # remove trailing empty line
   n = 1
   for line in lines:
      context.Log("%d: %s\n" % (n, line))
      n = n + 1
   context.Log("Error message: %s\n" % msg)

########################

def find_file( findThis, startDirs ) :
   for startDir in startDirs :
     for root, dirs, files in os.walk( startDir ) :
       if findThis in files :
         return os.path.join( root, findThis )
   return None


##############################

def TOOL_BUNDLE(env):

########################

    def BuildProgram(env,  name, srcs, deps, extraDefines = [], extraLinkFlags = [], buildAppBundle = 1, prefixHeader='inc/prefix/dtprefix.h') :
    
       target = '#bin/' + name
    
       if OS == 'windows' and mode == 'debug' :
          target += 'd'
    
       envProg = env.Copy()
    
       for lib in deps :
          if depsHash.has_key(lib) :
             for newLib in depsHash[lib] :
                if not newLib in deps :
                   deps.append(newLib)
       
       # merge external deps and delta libs
       # there's probably some function to do this
       allLibs = {}
       for lib_name in dtLibs.keys() :
          allLibs[lib_name] = dtLibs[lib_name]
       for lib_name in extLibs.keys() :
          allLibs[lib_name] = extLibs[lib_name]
          
       # change to platform+mode specific names
       deps = [ allLibs[lib] for lib in deps if allLibs.has_key(lib) ]
    
       addToLink = []
       if envProg.has_key('LINKFLAGS'):
         addToLink = envProg['LINKFLAGS']
    
       addToLibs = []
       addToFrameworks = []
       if OS == 'darwin':
          for lib_name in deps:
            if foundLibs.has_key(lib_name):
              #print lib_name + " is a " + foundLibs[lib_name] 
              if foundLibs[lib_name] == 'framework':
                #print "found " + lib_name + " as a framework"
                #addToLink.append('-framework')
                #addToLink.append(lib_name)
                addToFrameworks.append(lib_name)
              else:
                #print "found " + lib_name + " as a shared lib"
                addToLibs.append(lib_name)
            else:
              #print "Didn't find " + lib_name + ".  Defaulting to shared lib."
              addToLibs.append(lib_name);
       else:
          addToLibs = deps
       
       envProg['FRAMEWORKS'] = addToFrameworks

       cppDefines = []
       if envProg.has_key('CPPDEFINES'):
         cppDefines = envProg['CPPDEFINES']

       if prefixHeader != '' and envProg.get('usePrefixHeaders'):
          if OS == 'darwin' or OS == 'linux':
             envProg['CXXFLAGS'] += " -include " + prefixHeader
    
       program = envProg.Program( target, srcs, CPPDEFINES = cppDefines + extraDefines, LIBS = addToLibs, LINKFLAGS = addToLink + extraLinkFlags )
    
       if OS == 'darwin' and buildAppBundle:
          envProg ['VERSION_NUM'] = "1.2.0"
          envProg ['VERSION_NAME'] = name + '.app'
          bundle = envProg.MakeBundle ('#Applications/' + name + '.app', target,
                                  'old.delta3d.' + name,
                                  '#macosx/Info.plist',
                                  'APPL',
                                  'Dt3D',
                                  '#macosx/icons/Default.icns')
          envProg.Default (bundle)
    
          inst = envProg.InstallBundle ('$prefix/share/delta3d/Applications', bundle)
       elif OS == 'linux':
          if env.get('bindir') and launchDir+'/bin' != env.get('bindir'):
             envProg.Install( '$bindir', program )
          elif env.get('prefix') and launchDir != env.get('prefix') :
             envProg.Install( '$prefix/share/delta3d/bin', program )
       else:
          if launchDir != env.get('prefix') : 
             envProg.Install( '$prefix/share/delta3d/bin', program )
                   
########################
    
    def BuildLib(env, name, srcs, deps, extraDefines = [], extraLinkFlags = [],
          overrideShLinkFlags = '',  overrideShLibSuffix = '', prefixHeader='inc/prefix/dtprefix.h' ) :
    
       target = name
       if OS == 'windows' and mode == 'debug' :
          target += 'd'
          
       #add dependencies to global index
       depsHash[name] = deps
       
       envLib = env.Copy()
    
       if overrideShLinkFlags != '':
          envLib['SHLINKFLAGS'] = overrideShLinkFlags
       
       if overrideShLibSuffix != '':
          envLib['SHLIBSUFFIX'] = overrideShLibSuffix
    
       envLib['LIBNAME'] = name
    
       #expand pre-built libs
       for lib in deps :
          envLib.Depends(target,lib)
          if depsHash.has_key(lib) :
             for newLib in depsHash[lib] :
                if not newLib in deps :
                   deps.append(newLib)
          
       # merge external deps and delta libs
       # there's probably some function to do this
       allLibs = {}
       for lib_name in dtLibs.keys() :
          allLibs[lib_name] = dtLibs[lib_name]
       for lib_name in extLibs.keys() :
          allLibs[lib_name] = extLibs[lib_name]
          
       # change to platform+mode specific names
       deps = [ allLibs[lib] for lib in deps if allLibs.has_key(lib) ]
    
       addToLink = []
       if envLib.has_key('LINKFLAGS'):
         addToLink = envLib['LINKFLAGS']
    
       addToLibs = []
       addToFrameworks = []
       if OS == 'darwin':
          for lib_name in deps:
            if foundLibs.has_key(lib_name):
              if foundLibs[lib_name] == 'framework':
                #print "found " + lib_name + " as a framework"
                #addToLink.append('-framework')
                #addToLink.append(lib_name)
                addToFrameworks.append(lib_name)
              else:
                #print "found " + lib_name + " as a shared lib"
                addToLibs.append(lib_name)
            else:
              #print "Didn't find " + lib_name + ".  Defaulting to shared lib."
              addToLibs.append(lib_name);
       else:
          addToLibs = deps
   
       envLib['FRAMEWORKS'] = addToFrameworks
 
       cppDefines = []
       if envLib.has_key('CPPDEFINES'):
          cppDefines = envLib['CPPDEFINES']

       if prefixHeader != '' and envLib.get('usePrefixHeaders'):
          if OS == 'darwin' or OS == 'linux':
             envLib['CXXFLAGS'] += " -include " + prefixHeader
       
       if name != 'dtNet' :
          builtlib = envLib.SharedLibrary( target, srcs, CPPDEFINES = cppDefines + extraDefines,
                                           LIBS = addToLibs, LINKFLAGS = addToLink + extraLinkFlags )
       else :
          builtlib = envLib.StaticLibrary( target, srcs, CPPDEFINES = cppDefines + extraDefines,
                                           LIBS = addToLibs, LINKFLAGS = addToLink + extraLinkFlags )
          
       envLib.Precious( builtlib )
       
       if OS == 'windows' and name != 'dtNet' :
        
          lib = envLib.Install( '#/bin', builtlib[0] ) # .dll
          envLib.Install( '#/lib', builtlib[1] ) # .lib, 
          envLib.Install( '#/lib', builtlib[2] ) # .exp
    
          if launchDir != env.get('prefix') :
             envLib.Install( '$prefix/bin', builtlib[0] )
             envLib.Install( '$prefix/lib', builtlib[1] )
             envLib.Install( '$prefix/lib', builtlib[2] )
       else:

          # TODO: This should be a build dir settable by command-line params
          lib = envLib.Install( '#/lib', builtlib )

          if env.get('libdir') and env.get('libdir') != launchDir+'/lib':
             lib = envLib.Install( '$libdir', builtlib )
          elif launchDir != env.get('prefix'):
             lib = envLib.Install( '$prefix/lib', builtlib )
    
       incDirDict = { 'dtABC'       : 'dtABC',
                      'dtActors'    : 'dtActors',
                      'dtAudio'     : 'dtAudio',
                      'dtChar'      : 'dtChar',
                      'dtCore'      : 'dtCore',
                      'dtDAL'       : 'dtDAL',
                      'dtHLA'       : 'dtHLA',
                      'dtHLAGM'     : 'dtHLAGM',
                      'dtGUI'       : 'dtGUI',
                      'dtNet'       : 'dtNet',
                      'dtScript'    : 'dtScript',
                      'dtUtil'      : 'dtUtil',
                      'dtBSP'       : 'dtBSP',
                      'dtInspector' : 'dtInspector',
                      'dtTerrain'   : 'dtTerrain',
                      'dtGame'      : 'dtGame' }
    
       #install headers, there's gotta be a cleaner way ;)
       if incDirDict.has_key(name):
          if env.get('includedir') and launchDir+'/inc' != env.get('includedir'):
             for header in SGlob('../../inc/'+incDirDict[name]+'/*.h') :
                envLib.InstallAs( '$includedir/'+incDirDict[name]+'/'+os.path.basename(header), '../'+header )          
          elif env.get('prefix') and launchDir != env.get('prefix'):
             for header in SGlob('../../inc/'+incDirDict[name]+'/*.h') :
                envLib.InstallAs( '$prefix/include/'+incDirDict[name]+'/'+os.path.basename(header), '../'+header )
    
       return lib   

########################

    # This is not a regular Builder; it's a wrapper function.
    # So just make it available as a method of Environment.
    SConsEnvironment.BuildProgram = BuildProgram
    SConsEnvironment.BuildLib = BuildLib

############################

# Function to calculate current time for logging
def CurrentTime() :
   now = time.localtime()
   display = time.strftime('%A, %B %d %Y, %X', now)
   return display

########################

# Function to email the result of the build
def EmailResults() :
	file = open('BuildLog.txt', 'r')
	buffer = MIMEText(file.read())
	buffer['Subject'] = 'Editor Build Log'
	file.close()

	s = smtplib.SMTP()
	s.connect(smtpServer) 
	s.sendmail(fromAddress, peopleToEmail, buffer.as_string())
	s.close()
	
########################

def find_file( findThis, startDirs ) :
   for startDir in startDirs :
     for root, dirs, files in os.walk( startDir ) :
       if findThis in files :
         return os.path.join( root, findThis )
   return None

########################

def exit_with_error() :
	sys.stderr.write('Build failed.  See BuildLog.txt for details.\n')
	errorLog.write('Build Failed: Build ended: ' + CurrentTime() + '\n')
	errorLog.close()
	env.Exit(-1)	
   
########################

def CheckForBoost() :

   boostHeader = os.path.join('boost','python.hpp')
   
   if OS == 'windows' :
      boostLib = 'boost_python-vc71-mt.lib'
   elif OS == 'darwin' : 
      # This only has a hard-coded version since Boost.Python does not output
      # with the same file naming convention as other platform (as of 1.33.1)
      boostLib = 'libboost_python-1_33_1.dylib'
   else :
      boostLib = 'libboost_python-gcc-mt.so'
      
   foundLib = 0
   for dir in env['LIBPATH'] :
      if os.path.isfile( os.path.join( dir, boostLib ) ) :
         foundLib = 1
         break

   foundHeader = 0
   for dir in env['CPPPATH'] :
      if os.path.isfile( os.path.join( dir, boostHeader ) ) :
         foundHeader = 1
         break

   # If we don't find the lib name for Boost.Python 1.33 onward,
   # try the old library name instead...
   #if OS == 'linux' and foundLib == 0 :
   #   boostLib = 'libboost_python.so'

   #   for dir in env['LIBPATH'] :
   #      if os.path.isfile( os.path.join( dir, boostLib ) ) :
   #         foundLib = 1
   #         break

   return foundHeader != 0 and foundLib != 0

###########
# Options #
###########

# Open the error log
errorLog = open('BuildLog.txt', 'w')

print 'Build started: ' + CurrentTime() + ''
errorLog.write('Build started: ' + CurrentTime() + '\n\n')

print 'Platform: ' + sys.platform 

# detemine the OS
if sys.platform == 'win32' :
   OS = 'windows'	
elif sys.platform == 'linux2' or sys.platform == 'linux-i386' :
   OS = 'linux'
elif sys.platform == 'darwin' :
   OS = 'darwin'
else :
   print 'Build Failed: Unsupported platform'
   errorLog.write('Build Failed: Unsupported platform: ' + sys.platform)
   errorLog.close()
   env.Exit(-1) 

tools = ["default"]

if OS == 'darwin':
   tools.append(macosx.TOOL_BUNDLE)

tools.append(TOOL_BUNDLE)

# some basic command-line options
optCache = 'options.cache'
opts = Options(optCache)
opts.AddOptions(
   EnumOption( 'mode', 'Build as either debug or release', 'release',
            allowed_values = ( 'debug', 'release' ),
            map = {}, ignorecase = 1 ),
   BoolOption( 'usePrefixHeaders', 'use a prefix/precompiled header', False ),
   BoolOption( 'buildPythonBindings', 'compile the python binding libraries', True ),
   PackageOption( 'boost', 'Boost installation directory', 'no' ),
   PackageOption( 'rti', 'RTI installation directory', 'no' )
)

def CommaConverter( value ) :
   return value.split(',')

opts.Add( 'cpppath', 'Additional include directories (comma delimited)', converter=CommaConverter  )
opts.Add( 'libpath', 'Additional library directories (comma delimited)', converter=CommaConverter  )

if OS == 'windows' :
   opts.Add( PathOption( 'prefix', 'Directory to install under', os.getcwd() ) )
elif OS == 'linux':

   defaultLibDir = 'lib'
   if platform.architecture()[0] == '64bit' :
      defaultLibDir = 'lib64'
   
   opts.Add( PathOption( 'prefix', 'Directory to install under', '/usr/local' ) )
   opts.Add( PathOption( 'libdir', 'Directory to install libraries under (if set, this will override the normal prefix option)', '/usr/local/'+defaultLibDir ) )
   opts.Add( PathOption( 'bindir', 'Directory to install executables under (if set, this will override the normal prefix option)', '/usr/local/bin' ) )
   opts.Add( PathOption( 'includedir', 'Directory to install headers under (if set, this will override the normal prefix option)', '/usr/local/include' ) )
else :
   opts.Add( PathOption( 'prefix', 'Directory to install under', '/usr/local' ) )

env = Environment( options = opts, tools = tools )

# append the outside env to ours
for K in os.environ.keys():
   if K in env['ENV'].keys() and K in [ 'PATH', 'LD_LIBRARY_PATH', 'LIB', 'INCLUDE', 'QTDIR', 'CC', 'CXX', 'CPPPATH', 'LIBPATH' ]:
     env['ENV'][K]=SCons.Util.AppendPath( env['ENV'][K], os.environ[K] )
   else:
     env['ENV'][K]=os.environ[K]

if os.environ.has_key( 'CC' ) :
   env.Replace( CC = env['ENV']['CC'] )
if os.environ.has_key( 'CXX' ) :
   env.Replace( CXX = env['ENV']['CXX'] )  
     
# don't forget the Visual Studio paths...
if OS == 'windows' :
   if os.environ.has_key( 'INCLUDE' ) :
     env.Append( CPPPATH = env['ENV']['INCLUDE'].split(os.pathsep) )
   if os.environ.has_key( 'LIB' ) :
     env.Append( LIBPATH = env['ENV']['LIB'].split(os.pathsep) )

   # Python stuff
   vi = sys.version_info   
   python_version = 'python' + str(vi[0]) + str(vi[1])
   
   env.Append( CPPPATH = [os.path.join( sys.prefix, 'include' ) ] ) 
   env.Append( LIBPATH = [os.path.join( sys.prefix, 'libs' ) ] ) 

else :
   vi = sys.version_info   
   python_version = 'python' + str(vi[0])+'.'+str(vi[1])
   
   # Python stuff
   env.Append( CPPPATH = [os.path.join( sys.prefix, 'include',  python_version ) ] ) 
   env.Append( LIBPATH = [os.path.join( sys.prefix, 'lib',  python_version ) ] ) 
   
env.Append( CPPPATH = [os.path.join( os.getcwd(), 'inc' ) ] ) # Delta3D includes
env.Append( CPPPATH = [os.path.join( os.getcwd(), 'ext', 'inc' ) ] ) # Dependencies includes
env.Append( CPPPATH = [os.path.join( os.getcwd(), 'ext', 'inc', 'CEGUI' ) ] ) # path for Crazy Eddie's GUI since they are too cool

env.Append( CPPPATH = env.get('cpppath') )
env.Append( LIBPATH = env.get('libpath') )

if env['ENV'].has_key('QTDIR') :
   env.Append( TOOLS = 'qt' ) 

#add Xerces framework includes in case xerces is a framework
#since the xerces framework has broken headers.
#the Crazy eddie's case is similar, but they were wrtten not to have
#a parent directory, so the framework doesn't really work well with it
#anyway.
if OS == 'darwin':
   env.Append( CPPPATH = [os.path.join( os.getcwd(), 'ext', 'Frameworks', 'Xerces.framework', 'Headers' ) ] )
   env.Append( CPPPATH = [os.path.join( os.getcwd(), 'ext', 'Frameworks', 'CEGUI.framework', 'Headers' ) ] ) # path for Crazy Eddie's GUI since they are too cool
   env.Append( CPPPATH = [os.path.join( os.getcwd(), 'ext', 'Frameworks', 'gdal.framework', 'Headers' ) ] ) # gdal since the includes are not done as <gdal/...>

env.Append( LIBPATH = [os.path.join( os.getcwd(), 'lib' ) ] ) # Delta3D libs

extPath = os.path.join( os.getcwd(), 'ext', 'lib' )
if os.path.exists(extPath) :
   env.Append( LIBPATH = [extPath] ) # Dependencies libs

## Boost Python
if env.get('boost') not in [ 0, 1 ] and os.path.exists( env.get('boost') ) :
  
   env.Append( CPPPATH = [ env.get('boost') ] )
   
   libPath = os.path.join( env.get('boost'), 'lib' )
   if os.path.exists(libPath) :
      env.Append( LIBPATH = [libPath] )
   else :
      stagePath = os.path.join(env.get('boost'),'stage','lib')
      if os.path.exists(stagePath) :
         env.Append( LIBPATH = [stagePath] )
         
 # RTI 
rtiLibs = []
if env.get('rti') not in [ 0, 1 ] and os.path.exists( env.get('rti') ) and os.path.isdir( env.get('rti') ) :

   rtiHeader = find_file( 'RTI.hh', [ env.get('rti') ] )
   env.Append( CPPPATH = [ os.path.dirname( rtiHeader ) ] )
   
   if OS == 'windows' :      
     pattern = '(.*?)\.dll'
   elif OS == 'darwin' :
     pattern = 'lib(.*?)\.dylib'
   else :
     pattern = 'lib(.*?)\.so'

   rtiLibPath = ''
   for root, dirs, files in os.walk( env.get('rti') ) :
      for file in files :
         match = re.search( pattern, file )
         if match is not None :
            rtiLibPath = root
            rtiLibs.append( match.group(1) )

   if rtiLibPath is not '' :
      env.Append( LIBPATH = [ rtiLibPath ] )
      if 'rtiada' in rtiLibs :
         rtiLibs.remove('rtiada')
      if 'rtiadafedtime' in rtiLibs :
         rtiLibs.remove('rtiadafedtime')

Help( opts.GenerateHelpText( env ) )
opts.Save( 'delta3d.conf', env )

if env.get('mode') == 'debug':
   mode = 'debug'
elif env.get('mode') == 'release':
   mode = 'release'
else:
   print 'Build Failed: Unsupported mode'
   errorLog.write('Build Failed: Unsupportedmode: ' + sys.platform)
   errorLog.close()
   env.Exit(-1)

print 'OS: ' + OS
errorLog.write('OS: ' + OS + '\n\n')

# Set compiler options for debug/release modes
if mode == 'debug':
   print 'Build Configuration: Debug'
   errorLog.write('Build Configuration: Debug\n\n')
   
   if OS == 'windows':
      env.Append( CPPDEFINES = ['WIN32', '_DEBUG', '_NOAUTOLIBMSG'],
                  CXXFLAGS = ['/EHsc', '/GR', '/MDd' ], #synchronous exception handling (c-?), run-time type info, multi-threaded debug dll
                  LINKFLAGS = ['/NODEFAULTLIB:LIBCMTD', '/NODEFAULTLIB:LIBCD'] ) 
   elif OS == 'linux':      
      env.Append( CXXFLAGS=['-g', '-O0', '-pipe', '-fPIC'], #deubg info, no optimizations, pipe object data
                  #removed _DEBUG for now because of problem with GNE and DEBUG because of a python issue.
		  CPPDEFINES=['SIGSLOT_PURE_ISO'] )
   elif OS == 'darwin':      
      env.Append(CXXFLAGS=['-ggdb', '-O0', '-pipe', '-fPIC', '-isysroot', '/Developer/SDKs/MacOSX10.4u.sdk'], CPPDEFINES=['_DEBUG', '__USE_OSX_AGL_IMPLEMENTATION__', 'SIGSLOT_PURE_ISO', 'MAC_OS_X_VERSION_MIN_REQUIRED=1030' ],
	LINKFLAGS=['-Wl,-syslibroot,/Developer/SDKs/MacOSX10.4u.sdk'] )
else:
   print 'Build Configuration: Release'
   errorLog.write('Build Configuration: Release\n\n')
   
   if OS == 'windows':
     env.Append( CPPDEFINES = ['WIN32', 'NDEBUG', '_NOAUTOLIBMSG'],
              CXXFLAGS = ['/EHsc', '/GR', '/MD' ], #synchronous exception handling (c-?), run-time type info, multi-threaded dll
              LINKFLAGS = ['/NODEFAULTLIB:LIBCMT', '/NODEFAULTLIB:LIBC'] )  
   elif OS == 'linux':
     env.Append( CXXFLAGS=['-O2', '-pipe', '-fPIC'], #optimizations, pipe object data
              CPPDEFINES=['NDEBUG', 'SIGSLOT_PURE_ISO'],
              LINKFLAGS=['-s'] )
 #             LINKFLAGS=['-Wl,-rpath-link=' + env['ENV']['DELTA_ROOT'] + '/lib,-rpath-link=' + env['ENV']['DELTA_ROOT'] + '/ext/lib'] )

   elif OS == 'darwin':     
      env.Append(CXXFLAGS=['-Os', '-pipe', '-fPIC', '-isysroot', '/Developer/SDKs/MacOSX10.4u.sdk', '-arch', 'ppc', '-arch', 'i386'],
         CPPDEFINES=['NDEBUG', '__USE_OSX_AGL_IMPLEMENTATION__', 'SIGSLOT_PURE_ISO', 'MAC_OS_X_VERSION_MIN_REQUIRED=1030'], 
         LINKFLAGS=['-Wl,-syslibroot,/Developer/SDKs/MacOSX10.4u.sdk', '-arch', 'ppc', '-arch', 'i386'] )

#add to the CPPFLAGS variable if it's set in the environment
if os.environ.has_key('CPPFLAGS'):
   env.Append(CPPFLAGS=os.environ['CPPFLAGS'])

env.get('usePrefixHeaders')
   
if OS == 'windows':
   env.Append(CXXFLAGS=['/W3'])
elif OS == 'linux' or OS == 'darwin':
   if env['CC'][:3] == 'gcc' or env['CXX'][:3] == 'g++':
      env.Append(CXXFLAGS=['-Wall'])
      if env.has_key('CCVERSION') :
         if int( env['CCVERSION'][:1] ) >= 4 :
            env.Append(CXXFLAGS=['-ftree-vectorize'])
      if env.has_key('CXXVERSION') :
         if int( env['CXXVERSION'][:1] ) >= 4 :
            env.Append(CXXFLAGS=['-ftree-vectorize'])
   if env['CXX'][:3] == 'g++':
      env.Append(CXXFLAGS=['-Wno-non-virtual-dtor'])

if OS == 'linux' :
  env.Append(CPPPATH=['/usr/X11R6/include','/usr/include','/usr/local/include'])
  
  localCEGUIPath = '/usr/local/include/CEGUI'
  if os.path.exists( localCEGUIPath ) and os.path.isdir( localCEGUIPath ) :
     env.Append(CPPPATH=[localCEGUIPath])

  if platform.architecture()[0] == '64bit':
     env.Append(LIBPATH=['/usr/X11R6/lib64','/usr/lib64','/usr/local/lib64'])
  else:
     env.Append(LIBPATH=['/usr/X11R6/lib','/usr/lib','/usr/local/lib'])
if OS == 'darwin' :
  env.Append(CPPPATH=['/usr/include','/usr/local/include', '/usr/include/malloc'])
  env.Append(FRAMEWORKPATH=['ext/Frameworks' ])
  env['FRAMEWORKS'] = []
  env.Append(LIBPATH=['/usr/lib','/usr/local/lib'])
  env['SHLINKFLAGS'] = '$LINKFLAGS -Wl,-single_module -dynamiclib -compatibility_version 1 -current_version 3 -install_name "' + env.get('prefix') + '/lib/$SHLIBPREFIX$LIBNAME$SHLIBSUFFIX"'

launchDir = env.GetLaunchDir()

#############################################
# Configure: Testing for dependencies 
##############################################

def CheckLibOrFramework(context, lib, autoadd = 0):
      
   resultText = 0;

   if OS == 'darwin':
      result = conf.CheckFramework(lib, language = 'C++', autoadd = autoadd)
      if result:
         resultText = 'framework'
   else:
      result = False

   if not result:
      result = conf.CheckLib(lib, language = 'C++', autoadd = autoadd);
      if result:
         resultText = 'sharedLib'
   

   context.Result(result )
   return resultText

depsHash = {}

dtLibs = { 'dtABC'       : 'dtABC',
           'dtActors'    : 'dtActors',
           'dtAudio'     : 'dtAudio',
           'dtChar'      : 'dtChar',
           'dtCore'      : 'dtCore',
           'dtDAL'       : 'dtDAL',
           'dtHLA'       : 'dtHLA',
           'dtHLAGM'     : 'dtHLAGM',
           'dtGUI'       : 'dtGUI',
           'dtNet'       : 'dtNet',
           'dtScript'    : 'dtScript',
           'dtUtil'      : 'dtUtil',
           'dtBSP'       : 'dtBSP',
           'dtInspector' : 'dtInspector',
           'dtTerrain'   : 'dtTerrain', 
           'dtGame'      : 'dtGame',
	   'testGameActorLibrary' : 'testGameActorLibrary' }

if mode == 'debug' and OS == 'windows' :
   for lib in dtLibs :
      dtLibs[lib] = lib + 'd'
      
# platform-specific naming of dependencies
if OS == 'windows' :
   if mode == 'debug' :
      extLibs =  { 
         'CEGUIBase'           : 'CEGUIBase_d',
         'CEGUIOpenGLRenderer' : 'OpenGLGUIRenderer_d',
         'osg'                 : 'osgd',
         'osgDB'               : 'osgDBd',
         'osgUtil'             : 'osgUtild',
         'osgText'             : 'osgTextd',
         'osgSim'              : 'osgSimd',
         'osgFX'               : 'osgFXd',
         'osgParticle'         : 'osgParticled',
         'osgGA'               : 'osgGAd',
         'osgProducer'         : 'osgProducerd',
         'Producer'            : 'Producerd',
         'OpenThreads'         : 'OpenThreadsWin32d',
         'python'              : python_version,
         'cal3d'               : 'cal3d_d',
         'fltk'                : 'fltkd',
         'gdal'                : 'gdal_i',
         'gne'                 : 'gned',
         'HawkNL'              : 'NLstaticD',
         'isense'              : 'isensed',
         'openal'              : 'OpenAL32', 
         'alut'                : 'alut',       
         'ode'                 : 'oded', 
         'ul'                  : 'ul_d', 
         'js'                  : 'js_d',  
         'rvrutils'            : 'rvrutilsd',
         'rcfgscript'          : 'rcfgscriptd', 
         'rbody'               : 'ReplicantBodyd',
         'xerces-c'            : 'xerces-c_2D',
         'User32'              : 'User32',
         'Advapi32'            : 'Advapi32',
         'Rpcrt4'              : 'Rpcrt4',
         'Winmm'               : 'Winmm',
         'Gdi32'               : 'Gdi32',
         'opengl'              : 'Opengl32',
         'winsock'             : 'ws2_32',
         'shell32'             : 'shell32',
         'ole32'               : 'ole32',
         'Comctl32'            : 'Comctl32',
         'cppunit'             : 'cppunit' 
     }
   else :
      extLibs = { 
         'CEGUIBase'           : 'CEGUIBase',
         'CEGUIOpenGLRenderer' : 'OpenGLGUIRenderer',
         'osg'                 : 'osg',
         'osgDB'               : 'osgDB',
         'osgUtil'             : 'osgUtil',
         'osgText'             : 'osgText',
         'osgSim'              : 'osgSim',
         'osgFX'               : 'osgFX',
         'osgParticle'         : 'osgParticle',
         'osgGA'               : 'osgGA',
         'osgProducer'         : 'osgProducer',
         'Producer'            : 'Producer',
         'OpenThreads'         : 'OpenThreadsWin32',
         'python'              :  python_version,
         'cal3d'               : 'cal3d',
         'fltk'                : 'fltk',
         'gdal'                : 'gdal_i',
         'gne'                 : 'gne',
         'HawkNL'              : 'NLstatic',
         'isense'              : 'isense',
         'openal'              : 'OpenAL32', 
         'alut'                : 'alut',       
         'ode'                 : 'ode', 
         'ul'                  : 'ul', 
         'js'                  : 'js',  
         'rvrutils'            : 'rvrutils',
         'rcfgscript'          : 'rcfgscript', 
         'rbody'               : 'ReplicantBody',
         'xerces-c'            : 'xerces-c_2',
         'User32'              : 'User32',
         'Advapi32'            : 'Advapi32',
         'Rpcrt4'              : 'Rpcrt4',
         'Winmm'               : 'Winmm',
         'Gdi32'               : 'Gdi32',
         'opengl'              : 'Opengl32',
         'winsock'             : 'ws2_32',
         'shell32'             : 'shell32',
         'ole32'               : 'ole32', 
         'Comctl32'            : 'Comctl32',
         'cppunit'             : 'cppunit' 
         }
   
elif OS == 'linux' :
   extLibs = { 
      'CEGUIBase'           : 'CEGUIBase',
      'CEGUIOpenGLRenderer' : 'CEGUIOpenGLRenderer',
      'osg'                 : 'osg',
      'osgDB'               : 'osgDB',
      'osgUtil'             : 'osgUtil',
      'osgText'             : 'osgText',
      'osgSim'              : 'osgSim',
      'osgFX'               : 'osgFX',
      'osgParticle'         : 'osgParticle',
      'osgGA'               : 'osgGA',
      'osgProducer'         : 'osgProducer',
      'Producer'            : 'Producer',
      'python'              :  python_version,
      'OpenThreads'         : 'OpenThreads',
      'cal3d'               : 'cal3d',
      'fltk'                : 'fltk',
      'gdal'                : 'gdal',
      'gne'                 : 'gne',
      'HawkNL'              : 'NL',
      'isense'              : 'isense',
      'openal'              : 'openal',
      'alut'                : 'alut', 
      'ode'                 : 'ode', 
      'ul'                  : 'plibul', 
      'js'                  : 'plibjs',  
      'rvrutils'            : 'rvrutils',
      'rcfgscript'          : 'rcfgscript', 
      'rbody'               : 'rbody',
      'xerces-c'            : 'xerces-c',
      'Xxf86vm'             : 'Xxf86vm',
      'uuid'                : 'uuid',
      'opengl'              : 'GL',
      'cppunit'             : 'cppunit',
      'ncurses'             : 'ncurses'
      }
elif OS == 'darwin' :
   extLibs = { 
      'CEGUIBase'           : 'CEGUI',
      'CEGUIOpenGLRenderer' : 'CEGUIOpenGLRenderer',
      'osg'            : 'osg',
      'osgDB'          : 'osgDB',
      'osgUtil'        : 'osgUtil',
      'osgText'        : 'osgText',
      'osgSim'         : 'osgSim',
      'osgFX'          : 'osgFX',
      'osgParticle'    : 'osgParticle',
      'osgGA'          : 'osgGA',
      'osgProducer'    : 'osgProducer',
      'Producer'       : 'Producer',
#      'python'         : python_version,
#Default to the system level framework in OS X
      'python'         : 'Python',
      'OpenThreads'    : 'OpenThreads',
      'cal3d'          : 'cal3d',
      'fltk'           : 'fltk',
      'gdal'           : 'gdal',
      'gne'            : 'gne',
      'HawkNL'         : 'NL',
#      'isense'         : 'isense', # broken on intel
      'openal'         : 'OpenAL', 
#      'alut'           : 'alut',  # OSX is still on a staic alut     
      'ode'            : 'ode', 
      'ul'             : 'plibul', 
      'js'             : 'plibjs',  
      'rbody'          : 'rbody',
      'xerces-c'       : 'Xerces',
      'opengl'         : 'OpenGL',
      'CoreFoundation' : 'CoreFoundation',
      'IOKit'          : 'IOKit',
      'Carbon'         : 'Carbon',
      'cppunit'        : 'cppunit',
      'ncurses'        : 'ncurses'
      }
else :
   extLibs = {}

linkOrder = [
   'OpenThreads',
   'Producer',
   'opengl',
   'xerces-c',
   'gdal',
   'gne',
   'HawkNL',
   'osg',
   'osgDB',
   'osgUtil',
   'osgText',
   'osgSim',
   'osgFX',
   'osgParticle',
   'osgGA',
   'osgProducer']

if env.get('buildPythonBindings'):
   linkOrder += ['python']

linkOrder += [
   'cal3d',
   'fltk',
   'isense',
   'openal',
   'alut',
   'ode',
   'js',
   'ul',
   'rvrutils',
   'rcfgscript', 
   'rbody',
   'CEGUIBase',   
   'CEGUIOpenGLRenderer',
   'cppunit' ]

if OS == 'windows' :
   linkOrder = linkOrder + [ 'User32', 'Advapi32', 'Rpcrt4',  'Winmm', 'Gdi32', 'opengl', 'winsock', 'shell32', 'ole32' ]
elif OS == 'darwin' :
   linkOrder = [ 'CoreFoundation', 'IOKit', 'Carbon', 'ncurses' ] + linkOrder
elif OS == 'linux' :
   linkOrder = [ 'Xxf86vm', 'uuid', 'ncurses' ] + linkOrder 

foundLibs = {}

conf = Configure(env, custom_tests = {
   'CheckFramework' : CheckFramework,
   'CheckLibOrFramework': CheckLibOrFramework
   })

# TODO: don't run for install
if not env.GetOption('clean') :
    
   for lib in linkOrder :
      if extLibs.has_key(lib):
         foundLibs[extLibs[lib]] = conf.CheckLibOrFramework( extLibs[lib], autoadd = 1 )
#         if foundLibs[extLibs[lib]] == 'framework':
#            env.Append(LINKFLAGS = ' -framework ' + extLibs[lib])

   #this actually SEARCHES, not good
   #foundLibs[ os.path.join('boost','python.hpp') ] = conf.CheckHeader( os.path.join('boost','python.hpp'), language='C++')
   
   env = conf.Finish()

   # check if we found all the libraries
   # TODO: it's ok if we are missing boost_python, but make this explicit!
   if len( foundLibs.keys() ) < len( extLibs.keys() ) - 2  : 
     print 'Build Failed: Missing required libraries'
     errorLog.write('Build Failed: Missing required libraries\n\n')
     errorLog.close()

     if email == 'true' :
       EmailResults()
      
     env.Exit(-1)

# add the rti libs to the external library dictionary, but only
# after the configure check is complete 
for lib in rtiLibs :
   extLibs[lib] = lib
   
#################
# Build Delta3D #
#################

Export( 'env', 'OS', 'mode', 'SGlob', 'extLibs' , 'CheckForBoost', 
    'rtiLibs', 'foundLibs', 'depsHash', 'dtLibs', 'errorLog' )

env.SConsignFile()

Default( [ 'lib', 'bin', 'tests' ] )
if OS == 'darwin':
   Default(['Applications'])

env.Alias( 'python', [ os.path.join(os.getcwd(), 'src', 'python'),
                  os.path.join(os.getcwd(), 'examples', 'testPython')] )

env.Alias( 'hla', [ os.path.join(os.getcwd(), 'src', 'dtHLA'),
                os.path.join(os.getcwd(), 'examples', 'testHLA'),
                os.path.join(os.getcwd(), 'utilities', 'hlaStealthViewer') ] )

env.Alias( 'install', '$prefix' )

SConscript( dirs=['doc'] )
SConscript( dirs=['src'] )
SConscript( dirs=['examples'] )
SConscript( dirs=['utilities'] )

# TODO: this should defintely be using the env['TOOLS'] list and extracting the 'default' cxx tool,
#       problem is that on win32 the c_compiler and cxx_compiler are the same, so there's one
#       less element in the list, so we can't use an index to find the proper tool. instead we
#       need to query what scons chooses from the list and actually uses...
if OS == 'windows' :
   tool = 'msvc'
elif OS == 'linux' or OS == 'darwin' :
   tool = 'g++'

SConscript( dirs=['tests'], build_dir = os.path.join( 'tests', OS+'-'+tool+'-'+mode ), duplicate = 0 )

#if libs == '[]' :
#   errorLog.write('Failed to create the libraries or executable file')
#   errorLog.write('Build Failed: Build ended: ' + CurrentTime() + '\n')
#   errorLog.close()
#   env.Exit(-1)
#else :
#   # Close the error log and print the results
#   print 'Build Succeeded: Build ended: ' + CurrentTime()
#   errorLog.write('Build Succeeded: Build ended: ' + CurrentTime() + '\n')
#   errorLog.close()
#
#   # email the results
#   if email == 'true' :
#     EmailResults() 
