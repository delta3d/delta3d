import glob
import os 
import shutil
import re
import sys
import time
import smtplib
import string
import SCons.Util
import macosx
import SCons.Util
from SCons.Script.SConscript import SConsEnvironment

from email.MIMEText import MIMEText

# TODO:
# install headers, libs, to prefix
# fix dtCore/dtUtil auto-install
# doxygen
# make packaged release
# CVS support

########################
# Build error emailing #
########################

# set this to true to enable build emailing
email = 'false'

# fill this in with interested parties
peopleToEmail = []

# replcae with your local outgoing SMTP server
smtpServer = 'mysmtp@server.com'

SetOption('implicit_cache', 1)

# this is who the build email will come from
fromAddress = 'myaddress@company.com'

########################

def SGlob(pattern):
   path = string.replace(GetBuildPath('SConscript'),  'SConscript', '')

   result = []
   for i in glob.glob(path + pattern):
      result.append(string.replace(i, path, ''))

   return result 

########################

def _lang2suffix(lang):
   """
   Convert a language name to a suffix.
   When 'lang' is empty or None C is assumed.
   Returns a tuple (lang, suffix, None) when it works.
   For an unrecognized language returns (None, None, msg).
   Where:
      lang   = the unified language name
      suffix = the suffix, including the leading dot
      msg    = an error message
   """
   if not lang or lang in ["C", "c"]:
      return ("C", ".c", None)
   if lang in ["c++", "C++", "cpp", "CXX", "cxx"]:
      return ("C++", ".cpp", None)

   return None, None, "Unsupported language: %s" % lang

########################

def CheckFramework(context, frameworks, func_name = 'main', header = None, 
             extra_frameworks = None, extra_libs = None, 
             call = None, language = None, autoadd = 0):
   """
   Configure check for a C or C++ 'frameworks'.  Searches through
   the list of libraries, until one is found where the test succeeds.
   Tests if 'func_name' or 'call' exists in the library.  Note: if it exists
   in another library the test succeeds anyway!
   Optional 'header' can be defined to include a header file.  If not given a
   default prototype for 'func_name' is added.
   Optional 'extra_libs' is a list of library names to be added after
   'lib_name' in the build command.  To be used for libraries that 'lib_name'
   depends on.
   Optional 'call' replaces the call to 'func_name' in the test code.  It must
   consist of complete C statements, including a trailing ';'.
   There must either be a 'func_name' or a 'call' argument (or both).
   'language' should be 'C' or 'C++' and is used to select the compiler.
   Default is 'C'.
   Note that this uses the current value of compiler and linker flags, make
   sure $CFLAGS, $CPPFLAGS and $LIBS are set correctly.
   Returns an empty string for success, an error message for failure.
   """
   if not header:
      header = ""

   text = """
         %s """ % (header)

   # Add a function declaration if needed.
   if func_name and func_name != "main" and not header:
      text = text + """
            #ifdef __cplusplus
            extern "C"
            #endif
            char %s();""" % func_name

   # The actual test code.
   if not call:
      call = "%s();" % func_name
   text = text + """
         int
         main() {
         %s
         return 0;
         }
         \n\n""" % call

   i = string.find(call, "\n")
   if i > 0:
      calltext = call[:i] + ".."
   elif call[-1] == ';':
      calltext = call[:-1]
   else:
      calltext = call

   if not SCons.Util.is_List(frameworks):
      frameworks = [frameworks]


   oldLINK = context.env.get('LINKFLAGS', [])
   oldLIBS = context.env.get('LIBS', [])

   for framework_name in frameworks:

      lang, suffix, msg = _lang2suffix(language)
      if msg:
         context.Message("Cannot check for framework %s: %s\n" % (framework_name, msg))
         return msg

      context.Message("Checking for %s in %s framework %s... "
                  % (calltext, lang, framework_name))
      if framework_name:
         l = [ '-framework',  framework_name ]
         if extra_frameworks:
            for extra_framework_name in extra_frameworks:
               l.extend(' -framework ' + extra_framework_name)
               
         if extra_libs:
            context.env.Append(LIBS=extra_libs)
            
         context.env.Append(LINKFLAGS=l)
         sym = "HAVE_LIB" + framework_name
      else:
         sym = None

      ret = context.BuildProg(text, suffix)

      _YesNoResult(context, ret, sym, text)
      if ret != "" or autoadd == 0:
         context.env.Replace(LINKFLAGS = oldLINK)
      
      if oldLIBS != []:
         context.env.Replace(LIBS = oldLIBS)
     
      if ret == "":
         context.Result(1)
         return 1

   context.Result(0)
   return 0

########################

def _YesNoResult(context, ret, key, text):
   """
   Handle the result of a test with a 'yes' or 'no' result.
   'ret' is the return value: empty if OK, error message when not.
   'key' is the name of the symbol to be defined (HAVE_foo).
   'text' is the source code of the program used for testing.
   """
   if key:
      _Have(context, key, not ret)
   if ret:
      context.Display("no\n")
      _LogFailed(context, text, ret)
   else:
      context.Display("yes\n")

########################

def _Have(context, key, have):
   """
   Store result of a test in context.havedict and context.headerfilename.
   'key' is a 'HAVE_abc' name.  It is turned into all CAPITALS and ':./' are
   replaced by an underscore.
   The value of 'have' can be:
   1     - Feature is defined, add '#define key'.
   0     - Feature is not defined, add '/* #undef key */'.
          Adding 'undef' is what autoconf does.  Not useful for the
          compiler, but it shows that the test was done.
   number - Feature is defined to this number '#define key have'.
          Doesn't work for 0 or 1, use a string then.
   string - Feature is defined to this string '#define key have'.
          Give 'have' as is should appear in the header file, include quotes
          when desired and escape special characters!
   """
   key_up = string.upper(key)
   key_up = string.replace(key_up, ':', '_')
   key_up = string.replace(key_up, '.', '_')
   key_up = string.replace(key_up, '/', '_')
   key_up = string.replace(key_up, ' ', '_')
   context.havedict[key_up] = have
   if context.headerfilename:
      f = open(context.headerfilename, "a")
      if have == 1:
         f.write("#define %s\n" % key_up)
      elif have == 0:
         f.write("/* #undef %s */\n" % key_up)
      elif type(have) == IntType:
         f.write("#define %s %d\n" % (key_up, have))
      else:
         f.write("#define %s %s\n" % (key_up, str(have)))
      f.close()

########################

def _LogFailed(context, text, msg):
   """
   Write to the log about a failed program.
   Add line numbers, so that error messages can be understood.
   """
   context.Log("Failed program was:\n")
   lines = string.split(text, '\n')
   if len(lines) and lines[-1] == '':
      lines = lines[:-1]           # remove trailing empty line
   n = 1
   for line in lines:
      context.Log("%d: %s\n" % (n, line))
      n = n + 1
   context.Log("Error message: %s\n" % msg)

########################

def find_file( findThis, startDirs ) :
   for startDir in startDirs :
     for root, dirs, files in os.walk( startDir ) :
       if findThis in files :
         return os.path.join( root, findThis )
   return None


##############################

def TOOL_BUNDLE(env):

########################

    def BuildProgram(env,  name, srcs, deps, extraDefines = [], extraLinkFlags = [], buildAppBundle = 1) :
    
       target = '#bin/' + name
    
       if OS == 'windows' and mode == 'debug' :
          target += 'd'
    
       envProg = env.Copy()
    
       for lib in deps :
          if depsHash.has_key(lib) :
             for newLib in depsHash[lib] :
                if not newLib in deps :
                   deps.append(newLib)
       
       # merge external deps and delta libs
       # there's probably some function to do this
       allLibs = {}
       for lib_name in dtLibs.keys() :
          allLibs[lib_name] = dtLibs[lib_name]
       for lib_name in extLibs.keys() :
          allLibs[lib_name] = extLibs[lib_name]
          
       # change to platform+mode specific names
       deps = [ allLibs[lib] for lib in deps if allLibs.has_key(lib) ]
    
       addToLink = []
       if envProg.has_key('LINKFLAGS') and OS == 'windows':
         addToLink = envProg['LINKFLAGS']
    
       addToLibs = []
       if OS == 'darwin':
          addToLink.append('$FRAMEWORKSPATH')
          for lib_name in deps:
            if foundLibs.has_key(lib_name):
              if foundLibs[lib_name] == 'framework':
                #print "found " + lib_name + " as a framework"
                addToLink.append('-framework')
                addToLink.append(lib_name)
              else:
                #print "found " + lib_name + " as a shared lib"
                addToLibs.append(lib_name)
            else:
              #print "Didn't find " + lib_name + ".  Defaulting to shared lib."
              addToLibs.append(lib_name);
       else:
          addToLibs = deps
    
       cppDefines = []
       if envProg.has_key('CPPDEFINES'):
         cppDefines = envProg['CPPDEFINES']
    
       program = envProg.Program( target, srcs, CPPDEFINES = cppDefines + extraDefines, LIBS = addToLibs, LINKFLAGS = addToLink + extraLinkFlags )
    
       if OS == 'darwin' and buildAppBundle:
          env ['VERSION_NUM'] = "1.2.0"
          env ['VERSION_NAME'] = name + '.app'
          bundle = env.MakeBundle ('#Applications/' + name + '.app', target,
                                  'old.delta3d.' + name,
                                  '#macosx/Info.plist',
                                  'APPL',
                                  'Dt3D',
                                  '#macosx/icons/Default.icns')
          env.Default (bundle)
    
          inst = env.InstallBundle ('$prefix/share/delta3d/Applications', bundle)
       elif launchDir != env.get('prefix') :
          envProg.Install( '$prefix/share/delta3d/bin', program )
                    
########################
    
    def BuildLib(env, name, srcs, deps, extraDefines = [], extraLinkFlags = [],
          overrideShLinkFlags = '',  overrideShLibSuffix = '' ) :
    
       target = name
       if OS == 'windows' and mode == 'debug' :
          target += 'd'
          
       #add dependencies to global index
       depsHash[name] = deps
       
       envLib = env.Copy()
    
       if overrideShLinkFlags != '':
          envLib['SHLINKFLAGS'] = overrideShLinkFlags
       
       if overrideShLibSuffix != '':
          envLib['SHLIBSUFFIX'] = overrideShLibSuffix
    
       envLib['LIBNAME'] = name
    
       #expand pre-built libs
       for lib in deps :
          envLib.Depends(target,lib)
          if depsHash.has_key(lib) :
             for newLib in depsHash[lib] :
                if not newLib in deps :
                   deps.append(newLib)
          
       # merge external deps and delta libs
       # there's probably some function to do this
       allLibs = {}
       for lib_name in dtLibs.keys() :
          allLibs[lib_name] = dtLibs[lib_name]
       for lib_name in extLibs.keys() :
          allLibs[lib_name] = extLibs[lib_name]
          
       # change to platform+mode specific names
       deps = [ allLibs[lib] for lib in deps if allLibs.has_key(lib) ]
    
       addToLink = []
       if envLib.has_key('LINKFLAGS') and OS == 'windows':
         addToLink = envLib['LINKFLAGS']
    
       addToLibs = []
       if OS == 'darwin':
          addToLink.append('$FRAMEWORKSPATH')
          for lib_name in deps:
            if foundLibs.has_key(lib_name):
              if foundLibs[lib_name] == 'framework':
                #print "found " + lib_name + " as a framework"
                addToLink.append('-framework')
                addToLink.append(lib_name)
              else:
                #print "found " + lib_name + " as a shared lib"
                addToLibs.append(lib_name)
            else:
              #print "Didn't find " + lib_name + ".  Defaulting to shared lib."
              addToLibs.append(lib_name);
       else:
          addToLibs = deps
    
       cppDefines = []
       if envLib.has_key('CPPDEFINES'):
          cppDefines = envLib['CPPDEFINES']
       
       if name != 'dtNet' :
          builtlib = envLib.SharedLibrary( target, srcs, CPPDEFINES = cppDefines + extraDefines,
                                           LIBS = addToLibs, LINKFLAGS = addToLink + extraLinkFlags )
       else :
          builtlib = envLib.StaticLibrary( target, srcs, CPPDEFINES = cppDefines + extraDefines,
                                           LIBS = addToLibs, LINKFLAGS = addToLink + extraLinkFlags )
          
       envLib.Precious( builtlib )
       
       if OS == 'windows' and name != 'dtNet' :
        
          lib = envLib.Install( '#/bin', builtlib[0] ) # .dll
          envLib.Install( '#/lib', builtlib[1] ) # .lib, 
          envLib.Install( '#/lib', builtlib[2] ) # .exp
    
          if launchDir != env.get('prefix') :
             envLib.Install( '$prefix/bin', builtlib[0] )
             envLib.Install( '$prefix/lib', builtlib[1] )
             envLib.Install( '$prefix/lib', builtlib[2] )
       else:
    
          lib = envLib.Install( '#/lib', builtlib )
    
          if launchDir != env.get('prefix') :
             lib = envLib.Install( '$prefix/lib', builtlib )
    
       incDirDict = { 'dtABC'       : 'dtABC',
                      'dtActors'    : 'dtActors',
                      'dtAudio'     : 'dtAudio',
                      'dtChar'      : 'dtChar',
                      'dtCore'      : 'dtCore',
                      'dtDAL'       : 'dtDAL',
                      'dtHLA'       : 'dtHLA',
                      'dtGUI'       : 'dtGUI',
                      'dtNet'       : 'dtNet',
                      'dtScript'    : 'dtScript',
                      'dtUtil'      : 'dtUtil',
                      'dtBSP'       : 'dtBSP',
                      'dtInspector' : 'dtInspector',
                      'dtTerrain'   : 'dtTerrain',
                      'dtGame'      : 'dtGame' }
    
       #install headers, there's gotta be a cleaner way ;)
       if incDirDict.has_key(name) and launchDir != env.get('prefix') :
          for header in SGlob('../../inc/'+incDirDict[name]+'/*.h') :
             envLib.InstallAs( '$prefix/include/'+incDirDict[name]+'/'+os.path.basename(header), '../'+header )
    
       return lib   

########################

    def _lang2suffix(lang):
       """
       Convert a language name to a suffix.
       When 'lang' is empty or None C is assumed.
       Returns a tuple (lang, suffix, None) when it works.
       For an unrecognized language returns (None, None, msg).
       Where:
          lang   = the unified language name
          suffix = the suffix, including the leading dot
          msg    = an error message
       """
       if not lang or lang in ["C", "c"]:
          return ("C", ".c", None)
       if lang in ["c++", "C++", "cpp", "CXX", "cxx"]:
          return ("C++", ".cpp", None)
    
       return None, None, "Unsupported language: %s" % lang
    # This is not a regular Builder; it's a wrapper function.
    # So just make it available as a method of Environment.
    SConsEnvironment.BuildProgram = BuildProgram
    SConsEnvironment.BuildLib = BuildLib

############################

# Function to calculate current time for logging
def CurrentTime() :
   now = time.localtime()
   display = time.strftime('%A, %B %d %Y, %X', now)
   return display

########################

# Function to email the result of the build
def EmailResults() :
	file = open('BuildLog.txt', 'r')
	buffer = MIMEText(file.read())
	buffer['Subject'] = 'Editor Build Log'
	file.close()

	s = smtplib.SMTP()
	s.connect(smtpServer) 
	s.sendmail(fromAddress, peopleToEmail, buffer.as_string())
	s.close()
	
########################

def find_file( findThis, startDirs ) :
   for startDir in startDirs :
     for root, dirs, files in os.walk( startDir ) :
       if findThis in files :
         return os.path.join( root, findThis )
   return None

########################

def exit_with_error() :
	sys.stderr.write('Build failed.  See BuildLog.txt for details.\n')
	errorLog.write('Build Failed: Build ended: ' + CurrentTime() + '\n')
	errorLog.close()
	env.Exit(-1)	
   
########################

def CheckForBoost() :

   boostHeader = os.path.join('boost','python.hpp')

   if OS == 'windows' :
      if mode == 'debug' :
         boostLib = 'boost_python_debug.dll'
      else :
         boostLib = 'boost_python.dll'
   elif OS == 'linux' :
      boostLib = 'libboost_python.so'
   elif OS == 'darwin' :
      boostLib = 'libboost_python.dylib'

   foundLib = 0
   for dir in env['LIBPATH'] :
      if os.path.isfile( os.path.join( dir, boostLib ) ) :
         foundLib = 1
         break

   foundHeader = 0
   for dir in env['CPPPATH'] :
      if os.path.isfile( os.path.join( dir, boostHeader ) ) :
         foundHeader = 1
         break

   return foundHeader != 0 and foundLib != 0

###########
# Options #
###########

# Open the error log
errorLog = open('BuildLog.txt', 'w')

print 'Build started: ' + CurrentTime() + ''
errorLog.write('Build started: ' + CurrentTime() + '\n\n')

print 'Platform: ' + sys.platform 

# detemine the OS
if sys.platform == 'win32' :
   OS = 'windows'	
elif sys.platform == 'linux2' or sys.platform == 'linux-i386' :
   OS = 'linux'
elif sys.platform == 'darwin' :
   OS = 'darwin'
else :
   print 'Build Failed: Unsupported platform'
   errorLog.write('Build Failed: Unsupported platform: ' + sys.platform)
   errorLog.close()
   env.Exit(-1) 

tools = ["default"]

if OS == 'darwin':
   tools.append(macosx.TOOL_BUNDLE)

tools.append(TOOL_BUNDLE)

# some basic command-line options
optCache = 'options.cache'
opts = Options(optCache)
opts.AddOptions(
   EnumOption( 'mode', 'Build as either debug or release', 'release',
            allowed_values = ( 'debug', 'release' ),
            map = {}, ignorecase = 1 ),
   BoolOption( 'no_warnings', 'Disable all warnings', 0 ),
   BoolOption( 'unit_tests', 'Perform Unit Tests', 0 ),
   PackageOption( 'boost', 'Boost installation directory', 'no' ),
   PackageOption( 'rti', 'RTI installation directory', 'no' )
)

if OS == 'windows' :
   opts.Add( PathOption( 'prefix', 'Directory to install under', os.getcwd() ) )
else :
   opts.Add( PathOption( 'prefix', 'Directory to install under', '/usr/local' ) )

env = Environment( options = opts, tools = tools )

# append the outside env to ours
for K in os.environ.keys():
   if K in env['ENV'].keys() and K in [ 'PATH', 'LD_LIBRARY_PATH', 'LIB', 'INCLUDE', 'QTDIR', 'CC', 'CXX' ]:
     env['ENV'][K]=SCons.Util.AppendPath( env['ENV'][K], os.environ[K] )
   else:
     env['ENV'][K]=os.environ[K]

if os.environ.has_key( 'CC' ) :
   env.Replace( CC = env['ENV']['CC'] )
if os.environ.has_key( 'CXX' ) :
   env.Replace( CXX = env['ENV']['CXX'] )  
     
# don't forget the Visual Studio paths...
if OS == 'windows' :
   if os.environ.has_key( 'INCLUDE' ) :
     env.Append( CPPPATH = env['ENV']['INCLUDE'].split(os.pathsep) )
   if os.environ.has_key( 'LIB' ) :
     env.Append( LIBPATH = env['ENV']['LIB'].split(os.pathsep) )

   # Python stuff
   vi = sys.version_info   
   python_version = 'python' + str(vi[0]) + str(vi[1])
   
   env.Append( CPPPATH = [os.path.join( sys.prefix, 'include' ) ] ) 
   env.Append( LIBPATH = [os.path.join( sys.prefix, 'libs' ) ] ) 

else :
   vi = sys.version_info   
   python_version = 'python' + str(vi[0])+'.'+str(vi[1])
   
   # Python stuff
   env.Append( CPPPATH = [os.path.join( sys.prefix, 'include',  python_version ) ] ) 
   env.Append( LIBPATH = [os.path.join( sys.prefix, 'lib',  python_version ) ] ) 
   
env.Append( CPPPATH = [os.path.join( os.getcwd(), 'inc' ) ] ) # Delta3D includes
env.Append( CPPPATH = [os.path.join( os.getcwd(), 'ext', 'inc' ) ] ) # Dependencies includes
env.Append( CPPPATH = [os.path.join( os.getcwd(), 'ext', 'inc', 'CEGUI' ) ] ) # path for Crazy Eddie's GUI since they are too cool

if env['ENV'].has_key('QTDIR') :
   env.Append( TOOLS = 'qt' ) 

#add Xerces framework includes in case xerces is a framework
#since the xerces framework has broken headers.
#the Crazy eddie's case is similar, but they were wrtten not to have
#a parent directory, so the framework doesn't really work well with it
#anyway.
if OS == 'darwin':
   env.Append( CPPPATH = [os.path.join( os.getcwd(), 'ext', 'Frameworks', 'Xerces.framework', 'Headers' ) ] )
   env.Append( CPPPATH = [os.path.join( os.getcwd(), 'ext', 'Frameworks', 'CEGUI.framework', 'Headers' ) ] ) # path for Crazy Eddie's GUI since they are too cool
   env.Append( CPPPATH = [os.path.join( os.getcwd(), 'ext', 'Frameworks', 'gdal.framework', 'Headers' ) ] ) # gdal since the includes are not done as <gdal/...>

env.Append( LIBPATH = [os.path.join( os.getcwd(), 'lib' ) ] ) # Delta3D libs
env.Append( LIBPATH = [os.path.join( os.getcwd(), 'ext', 'lib' ) ] ) # Dependencies libs

## Boost Python
if env.get('boost') not in [ 0, 1 ] and os.path.exists( env.get('boost') ) and os.path.isdir( env.get('boost') ) :
   env.Append( CPPPATH = [ env.get('boost') ] )
   env.Append( LIBPATH = [ os.path.join( env.get('boost'), 'libs', 'python', 'build', 'bin-stage' ) ] )
     
 # RTI 
rtiLibs = []
if env.get('rti') not in [ 0, 1 ] and os.path.exists( env.get('rti') ) and os.path.isdir( env.get('rti') ) :

   rtiHeader = find_file( 'RTI.hh', [ env.get('rti') ] )
   env.Append( CPPPATH = [ os.path.dirname( rtiHeader ) ] )
   
   if OS == 'windows' :      
     pattern = '(.*?)\.dll'
   else :
     pattern = 'lib(.*?)\.so'

   rtiLibPath = ''
   rtiLibs = []
   for root, dirs, files in os.walk( env.get('rti') ) :
      for file in files :
         match = re.search( pattern, file )
         if match is not None :
            rtiLibPath = root
            rtiLibs.append( match.group(1) )

   if rtiLibPath is not '' :
      env.Append( LIBPATH = [ rtiLibPath ] )
      if 'rtiada' in rtiLibs :
         rtiLibs.remove('rtiada')
      if 'rtiadafedtime' in rtiLibs :
         rtiLibs.remove('rtiadafedtime')

Help( opts.GenerateHelpText( env ) )
opts.Save( 'delta3d.conf', env )

if env.get('mode') == 'debug':
   mode = 'debug'
elif env.get('mode') == 'release':
   mode = 'release'
else:
   print 'Build Failed: Unsupported mode'
   errorLog.write('Build Failed: Unsupportedmode: ' + sys.platform)
   errorLog.close()
   env.Exit(-1)

print 'OS: ' + OS
errorLog.write('OS: ' + OS + '\n\n')

# Set compiler options for debug/release modes
if mode == 'debug':
   print 'Build Configuration: Debug'
   errorLog.write('Build Configuration: Debug\n\n')
   
   if OS == 'windows':
      env.Append( CPPDEFINES = ['WIN32', '_DEBUG', '_NOAUTOLIBMSG'],
                  CXXFLAGS = ['/EHsc', '/GR', '/MDd' ], #synchronous exception handling (c-?), run-time type info, multi-threaded debug dll
                  LINKFLAGS = ['/NODEFAULTLIB:LIBCMTD', '/NODEFAULTLIB:LIBCD'] ) 
   elif OS == 'linux':      
      env.Append( CXXFLAGS=['-g', '-O0', '-pipe'], #deubg info, no optimizations, pipe object data
                  #removed _DEBUG for now because of problem with GNE and DEBUG because of a python issue.
		  CPPDEFINES=['SIGSLOT_PURE_ISO'] )
   elif OS == 'darwin':      
      env.Append(CXXFLAGS=['-g', '-O0', '-pipe'], CPPDEFINES=['_DEBUG', '__USE_OSX_AGL_IMPLEMENTATION__', 'SIGSLOT_PURE_ISO'  ])
else:
   print 'Build Configuration: Release'
   errorLog.write('Build Configuration: Release\n\n')
   
   if OS == 'windows':
     env.Append( CPPDEFINES = ['WIN32', 'NDEBUG', '_NOAUTOLIBMSG'],
              CXXFLAGS = ['/EHsc', '/GR', '/MD' ], #synchronous exception handling (c-?), run-time type info, multi-threaded dll
              LINKFLAGS = ['/NODEFAULTLIB:LIBCMT', '/NODEFAULTLIB:LIBC'] )  
   elif OS == 'linux':
     env.Append( CXXFLAGS=['-O2', '-pipe'], #optimizations, pipe object data
              CPPDEFINES=['NDEBUG', 'SIGSLOT_PURE_ISO'],
              LINKFLAGS=['-s'] )
 #             LINKFLAGS=['-Wl,-rpath-link=' + env['ENV']['DELTA_ROOT'] + '/lib,-rpath-link=' + env['ENV']['DELTA_ROOT'] + '/ext/lib'] )

   elif OS == 'darwin':     
     env.Append(CXXFLAGS=['-Os', '-pipe', '-mtune=G4'], CPPDEFINES=['NDEBUG', '__USE_OSX_AGL_IMPLEMENTATION__', 'SIGSLOT_PURE_ISO'  ])

#add to the CPPFLAGS variable if it's set in the environment
if os.environ.has_key('CPPFLAGS'):
   env.Append(CPPFLAGS=os.environ['CPPFLAGS'])
   
if env.get('no_warnings'):
   if OS == 'windows':
     env.Append(CXXFLAGS=['/w'])
   elif OS == 'linux' or OS == 'darwin':
     env.Append(CXXFLAGS=['-w'])
else:
   if OS == 'windows':
     env.Append(CXXFLAGS=['/W3'])
   elif OS == 'linux' or OS == 'darwin':
      if env['CC'][:3] == 'gcc' or env['CXX'][:3] == 'g++':
         env.Append(CXXFLAGS=['-Wall'])
         if env.has_key('CCVERSION') :
            if int( env['CCVERSION'][:1] ) >= 4 :
               env.Append(CXXFLAGS=['-ftree-vectorize'])
         if env.has_key('CXXVERSION') :
            if int( env['CXXVERSION'][:1] ) >= 4 :
               env.Append(CXXFLAGS=['-ftree-vectorize'])
      if env['CXX'][:3] == 'g++':
         env.Append(CXXFLAGS=['-Wno-non-virtual-dtor'])

if OS == 'linux' :
  env.Append(CPPPATH=['/usr/X11R6/include','/usr/include','/usr/local/include'])
  env.Append(LIBPATH=['/usr/X11R6/lib','/usr/lib','/usr/local/lib'])
if OS == 'darwin' :
  env.Append(CPPPATH=['/usr/include','/usr/local/include', '/usr/include/malloc'])
  env.Append(FRAMEWORKSPATH=['-F./ext/Frameworks' ])
  env.Append(CPPFLAGS=' $FRAMEWORKSPATH ' )
  env.Append(LINKFLAGS='$FRAMEWORKSPATH')
  env.Append(LIBPATH=['/usr/lib','/usr/local/lib'])
  env['SHLIBSUFFIX'] = '.dylib'
  env['SHLINKFLAGS'] = '$LINKFLAGS -arch ppc -prebind -Wl,-single_module -dynamiclib -compatibility_version 1 -current_version 1' 
   #-install_name "Frameworks/$(LIBNAME).framework/Versions/A/$(LIBNAME)"'

launchDir = env.GetLaunchDir()

#############################################
# Configure: Testing for dependencies 
##############################################

def CheckLibOrFramework(context, lib, autoadd = 0):
      
   resultText = 0;

   if OS == 'darwin':
      result = conf.CheckFramework(lib, language = 'C++', autoadd = autoadd)
      if result != 0:
         resultText = 'framework'
   else:
      result = 0

   if result == 0:
      result=conf.CheckLib(lib, language = 'C++', autoadd = autoadd);
      if result != 0:
         resultText = 'sharedLib'
   

   context.Result( result )
   return resultText

depsHash = {}

dtLibs = { 'dtABC'       : 'dtABC',
           'dtActors'    : 'dtActors',
           'dtAudio'     : 'dtAudio',
           'dtChar'      : 'dtChar',
           'dtCore'      : 'dtCore',
           'dtDAL'       : 'dtDAL',
           'dtHLA'       : 'dtHLA',
           'dtGUI'       : 'dtGUI',
           'dtNet'       : 'dtNet',
           'dtScript'    : 'dtScript',
           'dtUtil'      : 'dtUtil',
           'dtBSP'       : 'dtBSP',
           'dtInspector' : 'dtInspector',
           'dtTerrain'   : 'dtTerrain', 
           'dtGame'      : 'dtGame' }

if mode == 'debug' and OS == 'windows' :
   for lib in dtLibs :
      dtLibs[lib] = lib + 'd'
      
# platform-specific naming of dependencies
if OS == 'windows' :
   if mode == 'debug' :
      extLibs =  { 
         'CEGUIBase'           : 'CEGUIBase_d',
         'CEGUIOpenGLRenderer' : 'OpenGLGUIRenderer_d',
         'osg'                 : 'osgd',
         'osgDB'               : 'osgDBd',
         'osgUtil'             : 'osgUtild',
         'osgText'             : 'osgTextd',
         'osgSim'              : 'osgSimd',
         'osgFX'               : 'osgFXd',
         'osgParticle'         : 'osgParticled',
         'osgGA'               : 'osgGAd',
         'osgProducer'         : 'osgProducerd',
         'Producer'            : 'Producerd',
         'OpenThreads'         : 'OpenThreadsWin32d',
         'python'              : python_version,
         'cal3d'               : 'cal3d_d',
         'fltk'                : 'fltkd',
         'gdal'                : 'gdal_iD',
         'gne'                 : 'gned',
         'HawkNL'              : 'NLstaticD',
         'isense'              : 'isensed',
         'openal'              : 'OpenAL32', 
         'alut'                : 'alut',       
         'ode'                 : 'oded', 
         'ul'                  : 'ul_d', 
         'js'                  : 'js_d',  
         'rvrutils'            : 'rvrutilsd',
         'rcfgscript'          : 'rcfgscriptd', 
         'rbody'               : 'ReplicantBodyd',
         'xerces-c'            : 'xerces-c_2D',
         'User32'              : 'User32',
         'Advapi32'            : 'Advapi32',
         'Rpcrt4'              : 'Rpcrt4',
         'Winmm'               : 'Winmm',
         'Gdi32'               : 'Gdi32',
         'opengl'              : 'Opengl32',
         'winsock'             : 'ws2_32',
         'shell32'             : 'shell32',
         'ole32'               : 'ole32',
         'cppunit'             : 'cppunit' 
     }
   else :
      extLibs = { 
         'CEGUIBase'           : 'CEGUIBase',
         'CEGUIOpenGLRenderer' : 'OpenGLGUIRenderer',
         'osg'                 : 'osg',
         'osgDB'               : 'osgDB',
         'osgUtil'             : 'osgUtil',
         'osgText'             : 'osgText',
         'osgSim'              : 'osgSim',
         'osgFX'               : 'osgFX',
         'osgParticle'         : 'osgParticle',
         'osgGA'               : 'osgGA',
         'osgProducer'         : 'osgProducer',
         'Producer'            : 'Producer',
         'OpenThreads'         : 'OpenThreadsWin32',
         'python'              :  python_version,
         'cal3d'               : 'cal3d',
         'fltk'                : 'fltk',
         'gdal'                : 'gdal_i',
         'gne'                 : 'gne',
         'HawkNL'              : 'NLstatic',
         'isense'              : 'isense',
         'openal'              : 'OpenAL32', 
         'alut'                : 'alut',       
         'ode'                 : 'ode', 
         'ul'                  : 'ul', 
         'js'                  : 'js',  
         'rvrutils'            : 'rvrutils',
         'rcfgscript'          : 'rcfgscript', 
         'rbody'               : 'ReplicantBody',
         'xerces-c'            : 'xerces-c_2',
         'User32'              : 'User32',
         'Advapi32'            : 'Advapi32',
         'Rpcrt4'              : 'Rpcrt4',
         'Winmm'               : 'Winmm',
         'Gdi32'               : 'Gdi32',
         'opengl'              : 'Opengl32',
         'winsock'             : 'ws2_32',
         'shell32'             : 'shell32',
         'ole32'               : 'ole32', 
         'cppunit'             : 'cppunit' 
         }
   
elif OS == 'linux' :
   extLibs = { 
      'CEGUIBase'           : 'CEGUIBase',
      'CEGUIOpenGLRenderer' : 'CEGUIOpenGLRenderer',
      'osg'                 : 'osg',
      'osgDB'               : 'osgDB',
      'osgUtil'             : 'osgUtil',
      'osgText'             : 'osgText',
      'osgSim'              : 'osgSim',
      'osgFX'               : 'osgFX',
      'osgParticle'         : 'osgParticle',
      'osgGA'               : 'osgGA',
      'osgProducer'         : 'osgProducer',
      'Producer'            : 'Producer',
      'python'              :  python_version,
      'OpenThreads'         : 'OpenThreads',
      'cal3d'               : 'cal3d',
      'fltk'                : 'fltk',
      'gdal'                : 'gdal',
      'gne'                 : 'gne',
      'HawkNL'              : 'NL',
      'isense'              : 'isense',
      'openal'              : 'openal', 
      'alut'                : 'alut',       
      'ode'                 : 'ode', 
      'ul'                  : 'plibul', 
      'js'                  : 'plibjs',  
      'rvrutils'            : 'rvrutils',
      'rcfgscript'          : 'rcfgscript', 
      'rbody'               : 'rbody',
      'xerces-c'            : 'xerces-c',
      'Xxf86vm'             : 'Xxf86vm',
      'uuid'                : 'uuid',
      'opengl'              : 'GL',
      'cppunit'             : 'cppunit',
      'curses'              : 'curses'
      }
elif OS == 'darwin' :
   extLibs = { 
      'CEGUIBase'           : 'CEGUI',
      'CEGUIOpenGLRenderer' : 'CEGUIOpenGLRenderer',
      'osg'            : 'osg',
      'osgDB'          : 'osgDB',
      'osgUtil'        : 'osgUtil',
      'osgText'        : 'osgText',
      'osgSim'         : 'osgSim',
      'osgFX'          : 'osgFX',
      'osgParticle'    : 'osgParticle',
      'osgGA'          : 'osgGA',
      'osgProducer'    : 'osgProducer',
      'Producer'       : 'Producer',
      'python'         : 'Python',
      'OpenThreads'    : 'OpenThreads',
      'cal3d'          : 'cal3d',
      'fltk'           : 'fltk',
      'gdal'           : 'gdal',
      'gne'            : 'gne',
      'HawkNL'         : 'NL',
      'isense'         : 'isense',
      'openal'         : 'OpenAL', 
      'alut'           : 'alut',       
      'ode'            : 'ode', 
      'ul'             : 'plibul', 
      'js'             : 'plibjs',  
      'rbody'          : 'rbody',
      'xerces-c'       : 'Xerces',
      'opengl'         : 'OpenGL',
      'CoreFoundation' : 'CoreFoundation',
      'IOKit'          : 'IOKit',
      'Carbon'         : 'Carbon',
      'cppunit'        : 'cppunit',
      'curses'         : 'curses'
      }
else :
   extLibs = {}

linkOrder = [
   'OpenThreads',
   'Producer',
   'opengl',
   'xerces-c',
   'gdal',
   'gne',
   'HawkNL',
   'osg',
   'osgDB',
   'osgUtil',
   'osgText',
   'osgSim',
   'osgFX',
   'osgParticle',
   'osgGA',
   'osgProducer',
   'python',
   'cal3d',
   'fltk',
   'isense',
   'openal',
   'alut',
   'ode',
   'js',
   'ul',
   'rvrutils',
   'rcfgscript', 
   'rbody',
   'CEGUIBase',   
   'CEGUIOpenGLRenderer',
   'cppunit' ]

if OS == 'windows' :
   linkOrder = linkOrder + [ 'User32', 'Advapi32', 'Rpcrt4',  'Winmm', 'Gdi32', 'opengl', 'winsock', 'shell32', 'ole32' ]
elif OS == 'darwin' :
   linkOrder = [ 'CoreFoundation', 'IOKit', 'Carbon', 'curses' ] + linkOrder
elif OS == 'linux' :
   linkOrder = [ 'Xxf86vm', 'uuid', 'curses' ] + linkOrder 

foundLibs = {}

conf = Configure(env, custom_tests = {
   'CheckFramework' : CheckFramework,
   'CheckLibOrFramework': CheckLibOrFramework
   })

# TODO: don't run for install
if not env.GetOption('clean') :
    
   for lib in linkOrder :
      if extLibs.has_key(lib):
         foundLibs[extLibs[lib]] = conf.CheckLibOrFramework( extLibs[lib], autoadd = 1 )
         if foundLibs[extLibs[lib]] == 'framework':
            env.Append(LINKFLAGS = ' -framework ' + extLibs[lib])

   #this actually SEARCHES, not good
   #foundLibs[ os.path.join('boost','python.hpp') ] = conf.CheckHeader( os.path.join('boost','python.hpp') ,language='C++')
   
   env = conf.Finish()

   # check if we found all the libraries
   # TODO: it's ok if we are missing boost_python, but make this explicit!
   if len( foundLibs.keys() ) < len( extLibs.keys() ) - 2  : 
     print 'Build Failed: Missing required libraries'
     errorLog.write('Build Failed: Missing required libraries\n\n')
     errorLog.close()

     if email == 'true' :
       EmailResults()
      
     env.Exit(-1)

# add the rti libs to the external library dictionary, but only
# after the configure check is complete 
for lib in rtiLibs :
   extLibs[lib] = lib
   
#################
# Build Delta3D #
#################

Export( 'env', 'OS', 'mode', 'SGlob', 'extLibs' , 'CheckForBoost', 
    'rtiLibs', 'foundLibs', 'depsHash', 'dtLibs', 'errorLog' )

env.SConsignFile()

Default( [ 'lib', 'bin' ] )
if OS == 'darwin':
   Default(['Applications'])

env.Alias( 'python', [ os.path.join(os.getcwd(), 'src', 'python'),
                  os.path.join(os.getcwd(), 'examples', 'testPython')] )

env.Alias( 'hla', [ os.path.join(os.getcwd(), 'src', 'dtHLA'),
                os.path.join(os.getcwd(), 'examples', 'testHLA'),
                os.path.join(os.getcwd(), 'utilities', 'hlaStealthViewer') ] )

env.Alias( 'install', '$prefix' )

SConscript( dirs=['doc'] )
SConscript( dirs=['src'] )
SConscript( dirs=['examples'] )
SConscript( dirs=['utilities'] )

if env.get('unit_tests') or mode == 'debug' :
   SConscript( dirs=['tests'] )
   Default( [ 'tests' ] )

#if libs == '[]' :
#   errorLog.write('Failed to create the libraries or executable file')
#   errorLog.write('Build Failed: Build ended: ' + CurrentTime() + '\n')
#   errorLog.close()
#   env.Exit(-1)
#else :
#   # Close the error log and print the results
#   print 'Build Succeeded: Build ended: ' + CurrentTime()
#   errorLog.write('Build Succeeded: Build ended: ' + CurrentTime() + '\n')
#   errorLog.close()
#
#   # email the results
#   if email == 'true' :
#     EmailResults() 
