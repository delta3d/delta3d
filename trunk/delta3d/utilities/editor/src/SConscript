# Build script for actual level editor application.
import glob
import sys
import re
import os
import string

# Import the variables defined in the global SConstruct build script.
Import ('*')

if env['ENV'].has_key('QTDIR'):

   # The function returns a list of header files that contain the Q_OBJECT macro.  These
   # are then passed on the the moc builder.
   def getQObjectHeaders(headers) :
      passed = []
      pattern = re.compile("Q_OBJECT")

      #windows has issues with file paths, and since the headers are based
      # on the build path, we need to adjust.
      path = string.replace(GetBuildPath('SConscript'),  'SConscript', '')
   
      headersFixed = []
      for i in headers:
         headersFixed.append(path + i) 

      for header in headersFixed:
         f = open(header)
         while 1 :
            l = f.readline()
            if not l :
               break
            if re.search(pattern,l):
               passed.append(header)
               break   
         f.close()
   
      return passed
   
   # Environment settings for Qt
   qtdir = env['ENV']['QTDIR']
   
   env['QT_AUTOSCAN'] = 0
   env['QT_LIB'] = ''
   env['CXXFILESUFFIX'] = '.cpp'
      
   cppDefines = ['QT_THREAD_SUPPORT',
                   'QT_CORE_LIB',
                   'QT_GUI_LIB',
                   'QT_SHARED']
   
   if env['OS'] == 'linux' or env['OS'] == 'darwin':
      cppDefines += ['_REENTRANT']
   
   if env['OS'] == 'darwin':
      env.Append(CPPPATH = ['#/utilities/editor/inc'] )
   else:
      env.Append(CPPPATH = [qtdir + '/include','#/utilities/editor/inc'] )
   
   libs = ['QtCore','QtGui','QtOpenGL','dtDAL','dtAI','dtCore','dtUtil','dtAudio','dtChar','dtABC','dtGame'] 
   
   # First, glob the header directory to obtain a list of potential files to run
   # the moc builder on.
   if env['OS'] == 'windows':
      moc_headers = env.SGlob('..\inc\dtEditQt\*.h')
   else:
      moc_headers = env.SGlob('../inc/dtEditQt/*.h')

   # Next, grep each header file for the Q_OBJECT macro to determine if moc should be run on 
   # it.
   moc_headers = getQObjectHeaders(moc_headers)
   
   # We want the resulting moc files put in a moc subdirectory under the dtEditQt source
   # directory so we need to modify the pathnames of the sources to create the target output
   # file names.
   moc_targets = []
   for currHeader in moc_headers :
      if env['OS'] == 'windows':
         parts = currHeader.split("\\")
      else:
         parts = currHeader.split("/")
         
      target = parts[len(parts)-1][:-2]
         
      env['QT4_MOCFROMHFLAGS'] =['-Iutilities/editor/inc']
      moc_targets.append(env.Moc4(target=target, source=currHeader))

   initialSources = env.SGlob('*.cpp')

   if "precomp.cpp" in initialSources:
      initialSources.remove("precomp.cpp")

   #must be built separately.

   if env.get('fastBuild'):
      if "taskuiplugin.cpp" in initalSources:
         initialSources.remove("taskuiplugin.cpp")
      
      path = string.replace(env.GetBuildPath('SConscript'),  'SConscript', '')
      cxxFileName = "STAGE.cxx"
      cxxFile = open(path + cxxFileName, "w")
      for srcFile in initalSources :
         cxxFile.write("#include \"" + srcFile + "\"\n")   
      
      sources = [cxxFileName, "taskuiplugin.cpp"] + moc_targets
   else:
      sources = initialSources + moc_targets

         
   # Build the icon
   if env['OS'] == 'windows' :
      sources += env.RES( '#utilities\editor\dtEditQt.rc' )

   #appName = '#/bin/STAGE'
	
   #if mode == 'debug' and env['OS'] == 'windows' :
   #   appName += 'd'

   #prefixHeader = "inc/prefix/dtstageprefix.h"

   #addMap = env.SetupDepsAndPCH(env, libs, prefixHeader)
       
   #addToLink = addMap['addToLink']
   #addToLibs = addMap['addToLibs']

   #app = env.Program('#/bin/STAGE', sources, LIBS = addToLibs, 
   #	LINKFLAGS = addToLink)
    
   app = env.BuildProgram('STAGE', sources, libs, cppDefines, prefixHeader = "inc/prefix/dtstageprefix.h")
      
   if (app == '[]') :
      result = 'false'
   else :
      result = 'true'
   
   if (result == 'false') :
      errorLog.write("Failed to build the level editor application.\n")
   
   Return('result')
