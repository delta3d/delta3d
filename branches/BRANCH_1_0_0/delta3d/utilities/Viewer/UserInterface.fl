# data file for the Fltk User Interface Designer (fluid)
version 1.0105 
header_name {.h} 
code_name {.cxx}
decl {\#include <string>} {public
} 

decl {\#include <FL/Fl_Choice.h>} {public
} 

decl {\#include <FL/Fl_File_Chooser.h>} {public
} 

decl {\#include "viewwindow.h"} {public
} 

decl {\#include "viewstate.h"} {public
} 

decl {\#define kDefFltr "Geometry Files (*.{osg,ive,flt,3ds})\\tOSG Files (*.osg)\\tIVE Files (*.ive)\\tFlight Files (*.flt)\\t3ds Export Files (*.3ds)"} {public
} 

decl {class ChoicePopUp;   // forward reference} {public
} 

class UserInterface {open
} {
  decl {int mArgc;} {}
  decl {char** mArgv;} {}
  decl {bool mMenusEnabled;} {}
  Function {UserInterface( int argc = 0L, char** argv = NULL ) : mArgc(argc), mArgv(argv), mMenusEnabled(false)} {open
  } {
    Fl_Window UIMainWindow {
      label Viewer open
      private xywh {840 178 640 544} type Double resizable non_modal visible
    } {
      Fl_Menu_Bar UIMenu {open
        private xywh {0 0 640 24}
      } {
        submenu UIMenuFile {
          label {&File}
          private xywh {0 0 100 20}
        } {
          menuitem UIMenuFileOpen {
            label {&Open}
            callback {const char* path	= UIViewWindow->GetPath();

	Fl_File_Chooser	fileChooser( path, kDefFltr, Fl_File_Chooser::SINGLE, "Load File" );
	fileChooser.preview( 0 );
	fileChooser.show();

	while( fileChooser.visible() )
		Fl::wait();

	if( fileChooser.count() > 0 )
	{
		UIViewWindow->SetPath( fileChooser.directory() );
		LoadFile( fileChooser.value() );
	}}
            private xywh {0 0 100 20} divider
          }
          menuitem UIMenuFileSaveAs {
            label {&Save As...}
            callback {char *filename = fl_file_chooser("Save File", 
	"Geometry Files (*.{osg,ive})\\tOSG Files (*.osg)\\tIVE Files (*.ive)",
	 UIFileList->text() );

	if (filename != NULL)
	{
		SaveFileAs(filename);
	}}
            private xywh {10 10 100 20} deactivate divider
          }
          menuitem UIMenuFileQuit {
            label {&Quit}
            callback {Quit();}
            private xywh {0 0 100 20}
          }
        }
        submenu UIMenuView {
          label {&View} open
          private xywh {0 0 100 20} deactivate
        } {
          submenu UIMenuViewDisplay {
            label {&Display}
            private xywh {0 0 100 20}
          } {
            menuitem UIMenuViewDisplayCompass {
              label {&Compass}
              callback {UIViewWindow->SetDisplay( ViewState::COMPASS, UIMenuViewDisplayCompass->value() != 0L );}
              private xywh {5 5 100 20} type Toggle divider
            }
            menuitem UIMenuViewDisplayXYPlane {
              label {&XY Plane}
              callback {UIViewWindow->SetDisplay( ViewState::XY_PLANE, UIMenuViewDisplayXYPlane->value() != 0L );}
              private xywh {5 5 100 20} type Toggle
            }
            menuitem UIMenuViewDisplayYZPlane {
              label {&YZ Plane}
              callback {UIViewWindow->SetDisplay( ViewState::YZ_PLANE, UIMenuViewDisplayYZPlane->value() != 0L );}
              private xywh {15 15 100 20} type Toggle
            }
            menuitem UIMenuViewDisplayZXPlane {
              label {&ZX Plane}
              callback {UIViewWindow->SetDisplay( ViewState::ZX_PLANE, UIMenuViewDisplayZXPlane->value() != 0L );}
              private xywh {25 25 100 20} type Toggle
            }
          }
          submenu UIMenuViewScene {
            label {&Scene} open
            private xywh {0 0 100 20}
          } {
            menuitem UIMenuViewScenePolygon {
              label {&Polygon}
              callback {bool	on(UIMenuViewScenePolygon->value() != 0L);

	UIViewWindow->SetDisplay( ViewState::SCENEPOLY, on );

	if( on )
	{
		UIMenuViewSceneTexture->activate();
		UIMenuViewSceneLighting->activate();
	}}
              private xywh {10 10 100 20} type Radio
            }
            menuitem UIMenuViewSceneWireframe {
              label {&Wireframe}
              callback {bool	on(UIMenuViewSceneWireframe->value() != 0L);

	UIViewWindow->SetDisplay( ViewState::SCENEWIRE, on );

	if( on )
	{
		UIMenuViewSceneTexture->deactivate();
		UIMenuViewSceneLighting->deactivate();
	}}
              private xywh {45 45 100 20} type Radio
            }
            menuitem UIMenuViewSceneScribe {
              label {&Scribe}
              callback {bool	on(UIMenuViewSceneScribe->value() != 0L);

	UIViewWindow->SetDisplay( ViewState::SCENEPOLY | ViewState::SCENEWIRE, on );

	if( on )
	{
		UIMenuViewSceneTexture->activate();
		UIMenuViewSceneLighting->activate();
	}}
              private xywh {55 55 100 20} type Radio divider
            }
            menuitem UIMenuViewSceneTexture {
              label {&Texture}
              callback {UIViewWindow->SetDisplay( ViewState::SCENETXT, UIMenuViewSceneTexture->value() != 0L );}
              private xywh {10 10 100 20} type Toggle
            }
            menuitem UIMenuViewSceneLighting {
              label {&Lighting}
              callback {UIViewWindow->SetDisplay( ViewState::SCENELIGHT, UIMenuViewSceneLighting->value() != 0L );} selected
              private xywh {10 10 100 20} type Toggle
            }
          }
          submenu UIMenuViewModel {
            label {&Model} open
            private xywh {0 0 100 20} divider
          } {
            menuitem UIMenuViewModelPolygon {
              label {&Polygon}
              callback {bool	on(UIMenuViewModelPolygon->value() != 0L);

	UIViewWindow->SetDisplay( ViewState::POLYGON, on );

	if( on )
	{
		UIMenuViewModelTexture->activate();
		UIMenuViewModelLighting->activate();
	}}
              private xywh {0 0 100 20} type Radio
            }
            menuitem UIMenuViewModelWireframe {
              label {&Wireframe}
              callback {bool	on(UIMenuViewModelWireframe->value() != 0L);

	UIViewWindow->SetDisplay( ViewState::WIREFRAME, on );

	if( on )
	{
		UIMenuViewModelTexture->deactivate();
		UIMenuViewModelLighting->deactivate();
	}}
              private xywh {35 35 100 20} type Radio
            }
            menuitem UIMenuViewModelScribe {
              label {&Scribe}
              callback {bool	on(UIMenuViewModelScribe->value() != 0L);

	UIViewWindow->SetDisplay( ViewState::POLYGON | ViewState::WIREFRAME, on );

	if( on )
	{
		UIMenuViewModelTexture->activate();
		UIMenuViewModelLighting->activate();
	}}
              private xywh {45 45 100 20} type Radio divider
            }
            menuitem UIMenuViewModelTexture {
              label {&Texture}
              callback {UIViewWindow->SetDisplay( ViewState::TEXTURE, UIMenuViewModelTexture->value() != 0L );}
              private xywh {0 0 100 20} type Toggle
            }
            menuitem UIMenuViewModelLighting {
              label {&Lighting}
              callback {UIViewWindow->SetDisplay( ViewState::LIGHTING, UIMenuViewModelLighting->value() != 0L );}
              private xywh {0 0 100 20} type Toggle
            }
          }
          menuitem UIMenuViewResetCam {
            label {&Reset Camera}
            callback {UIViewWindow->SetDisplay( ViewState::RESET );}
            private xywh {40 40 100 20}
          }
        }
        submenu UIMenuMotion {
          label {&Motion}
          private xywh {0 0 100 20} deactivate
        } {
          menuitem UIMenuMotionFly {
            label {&Fly}
            callback {UIViewWindow->SetMotion( ViewState::FLY );}
            private xywh {0 0 100 20} type Radio
          }
          menuitem UIMenuMotionOrbit {
            label {&Orbit}
            callback {UIViewWindow->SetMotion( ViewState::ORBIT );}
            private xywh {0 0 100 20} type Radio
          }
          menuitem UIMenuMotionUFO {
            label {&UFO}
            callback {UIViewWindow->SetMotion( ViewState::UFO );}
            private xywh {0 0 100 20} type Radio
          }
          menuitem UIMenuMotionWalk {
            label {&Walk}
            callback {UIViewWindow->SetMotion( ViewState::WALK );}
            private xywh {10 10 100 20} type Radio divider
          }
          menuitem UIMenuMotionJoy1 {
            label {Joystick &1}
            callback {UIViewWindow->SetJoystick( ViewState::JOY_1, UIMenuMotionJoy1->value() != 0L );}
            private xywh {20 20 100 20} type Toggle deactivate
          }
          menuitem UIMenuMotionJoy2 {
            label {Joystick &2}
            callback {UIViewWindow->SetJoystick( ViewState::JOY_2, UIMenuMotionJoy2->value() != 0L );}
            private xywh {30 30 100 20} type Toggle deactivate
          }
        }
      }
      Fl_Box UIViewWindow {
        label ViewWindow
        private xywh {0 24 640 480} resizable
        code0 {\#include "viewwindow.h"}
        class ViewWindow
      }
      Fl_Choice UIFileList {
        label {File:}
        private xywh {36 512 600 24} down_box BORDER_BOX
        class ChoicePopUp
      } {}
    }
    code {UIViewWindow->Container( this );} {}
  }
  Function {Show()} {} {
    code {UIMainWindow->show();
	UIViewWindow->CommandLine( mArgc, mArgv );} {}
  }
  Function {Quit()} {} {
    code {UIMainWindow->hide();} {}
  }
  Function {LoadFile( std::string pathfile )} {open
  } {
    code {if( pathfile == "" )
		return;

	bool fileLoaded = UIViewWindow->LoadFile( pathfile.c_str() );
	if (fileLoaded)
	{
		UIFileList->InsertFile( pathfile, UIViewWindow );

		if( ! mMenusEnabled )
		{
			UIMenuView->activate();
			UIMenuMotion->activate();
			UIMenuFileSaveAs->activate();
			mMenusEnabled	= true;
		}
	}} {}
  }
  Function {SaveFileAs( std::string pathfile )} {open
  } {
    code {if( pathfile == "" )
		return;

	bool fileSaved = UIViewWindow->SaveFileAs( pathfile.c_str() );
	
	if (fileSaved)
	{

	}} {}
  }
  Function {SelectFile( int indx )} {} {
    code {UIViewWindow->SelectFile( indx );
	UIFileList->SelectFile( indx );} {}
  }
  Function {UpdateSettings( const ViewState* pViewState )} {} {
    code {assert( pViewState );


	// display items
	if( pViewState->GetDisplayFlag( ViewState::COMPASS ) )
		UIMenuViewDisplayCompass->set();
	else
		UIMenuViewDisplayCompass->clear();

	if( pViewState->GetDisplayFlag( ViewState::XY_PLANE ) )
		UIMenuViewDisplayXYPlane->set();
	else
		UIMenuViewDisplayXYPlane->clear();

	if( pViewState->GetDisplayFlag( ViewState::YZ_PLANE ) )
		UIMenuViewDisplayYZPlane->set();
	else
		UIMenuViewDisplayYZPlane->clear();

	if( pViewState->GetDisplayFlag( ViewState::ZX_PLANE ) )
		UIMenuViewDisplayZXPlane->set();
	else
		UIMenuViewDisplayZXPlane->clear();


	// scene features
	if( pViewState->GetDisplayFlag( ViewState::SCENEWIRE ) )
	{
		UIMenuViewSceneWireframe->set();
		UIMenuViewSceneTexture->deactivate();
		UIMenuViewSceneLighting->deactivate();
	}
	else
		UIMenuViewSceneWireframe->clear();

	if( pViewState->GetDisplayFlag( ViewState::SCENEPOLY ) )
	{
		UIMenuViewScenePolygon->set();
		UIMenuViewSceneTexture->activate();
		UIMenuViewSceneLighting->activate();
	}
	else
		UIMenuViewScenePolygon->clear();

	if( pViewState->GetDisplayFlag( ViewState::SCENEWIRE )	&&
	    pViewState->GetDisplayFlag( ViewState::SCENEPOLY )	)
	{
		UIMenuViewScenePolygon->clear();
		UIMenuViewSceneWireframe->clear();
		UIMenuViewSceneScribe->set();
	}
	else
	{
		UIMenuViewSceneScribe->clear();
	}

	if( pViewState->GetDisplayFlag( ViewState::SCENETXT ) )
		UIMenuViewSceneTexture->set();
	else
		UIMenuViewSceneTexture->clear();

	if( pViewState->GetDisplayFlag( ViewState::SCENELIGHT ) )
		UIMenuViewSceneLighting->set();
	else
		UIMenuViewSceneLighting->clear();


	// model features
	if( pViewState->GetDisplayFlag( ViewState::WIREFRAME ) )
	{
		UIMenuViewModelWireframe->set();
		UIMenuViewModelTexture->deactivate();
		UIMenuViewModelLighting->deactivate();
	}
	else
		UIMenuViewModelWireframe->clear();

	if( pViewState->GetDisplayFlag( ViewState::POLYGON ) )
	{
		UIMenuViewModelPolygon->set();
		UIMenuViewModelTexture->activate();
		UIMenuViewModelLighting->activate();
	}
	else
		UIMenuViewModelPolygon->clear();

	if( pViewState->GetDisplayFlag( ViewState::WIREFRAME )	&&
	   pViewState->GetDisplayFlag( ViewState::POLYGON )	)
	{
		UIMenuViewModelPolygon->clear();
		UIMenuViewModelWireframe->clear();
		UIMenuViewModelScribe->set();
	}
	else
	{
		UIMenuViewModelScribe->clear();
	}

	if( pViewState->GetDisplayFlag( ViewState::TEXTURE ) )
		UIMenuViewModelTexture->set();
	else
		UIMenuViewModelTexture->clear();

	if( pViewState->GetDisplayFlag( ViewState::LIGHTING ) )
		UIMenuViewModelLighting->set();
	else
		UIMenuViewModelLighting->clear();


	// motion models
	if( pViewState->GetMotionFlag( ViewState::WALK ) )
		UIMenuMotionWalk->setonly();
	else
		UIMenuMotionWalk->clear();

	if( pViewState->GetMotionFlag( ViewState::FLY ) )
		UIMenuMotionFly->setonly();
	else
		UIMenuMotionFly->clear();

	if( pViewState->GetMotionFlag( ViewState::UFO ) )
		UIMenuMotionUFO->setonly();
	else
		UIMenuMotionUFO->clear();

	if( pViewState->GetMotionFlag( ViewState::ORBIT ) )
		UIMenuMotionOrbit->setonly();
	else
		UIMenuMotionOrbit->clear();


	// joysticks
	if( pViewState->GetJoystickFlag( ViewState::JOY_1 ) )
		UIMenuMotionJoy1->set();
	else
		UIMenuMotionJoy1->clear();

	if( pViewState->GetJoystickFlag( ViewState::JOY_2 ) )
		UIMenuMotionJoy2->set();
	else
		UIMenuMotionJoy2->clear();} {}
  }
  Function {ToggleWireframeModel()} {} {
    code {Fl::focus( UIViewWindow );

	if( UIMenuViewModelPolygon->value() )
	{
		UIViewWindow->SetDisplay( ViewState::WIREFRAME, true );

		UIMenuViewModelWireframe->setonly();

		UIMenuViewModelTexture->deactivate();
		UIMenuViewModelLighting->deactivate();

		return;
	}

	if( UIMenuViewModelWireframe->value() )
	{
		UIViewWindow->SetDisplay( ViewState::POLYGON | ViewState::WIREFRAME, true );

		UIMenuViewModelScribe->setonly();

		UIMenuViewModelTexture->activate();
		UIMenuViewModelLighting->activate();

		return;
	}

	if( UIMenuViewModelScribe->value() )
	{
		UIViewWindow->SetDisplay( ViewState::POLYGON, true );

		UIMenuViewModelPolygon->setonly();

		UIMenuViewModelTexture->activate();
		UIMenuViewModelLighting->activate();

		return;
	}} {}
  }
  Function {ToggleWireframeScene()} {} {
    code {Fl::focus( UIViewWindow );

	if( UIMenuViewScenePolygon->value() )
	{
		UIViewWindow->SetDisplay( ViewState::SCENEWIRE, true );

		UIMenuViewSceneWireframe->setonly();

		UIMenuViewSceneTexture->deactivate();
		UIMenuViewSceneLighting->deactivate();

		return;
	}

	if( UIMenuViewSceneWireframe->value() )
	{
		UIViewWindow->SetDisplay( ViewState::SCENEPOLY | ViewState::SCENEWIRE, true );

		UIMenuViewSceneScribe->setonly();

		UIMenuViewSceneTexture->activate();
		UIMenuViewSceneLighting->activate();

		return;
	}

	if( UIMenuViewSceneScribe->value() )
	{
		UIViewWindow->SetDisplay( ViewState::SCENEPOLY, true );

		UIMenuViewScenePolygon->setonly();

		UIMenuViewSceneTexture->activate();
		UIMenuViewSceneLighting->activate();

		return;
	}} {}
  }
  Function {ToggleLightingModel()} {} {
    code {Fl::focus( UIViewWindow );

	if( UIMenuViewModelLighting->active() )
	{
		if( UIMenuViewModelLighting->value() )
		{
			UIMenuViewModelLighting->clear();
			UIViewWindow->SetDisplay( ViewState::LIGHTING, false );
		}
		else
		{
			UIMenuViewModelLighting->set();
			UIViewWindow->SetDisplay( ViewState::LIGHTING, true );
		}
  	}} {}
  }
  Function {ToggleLightingScene()} {} {
    code {Fl::focus( UIViewWindow );

	if( UIMenuViewSceneLighting->active() )
	{
		if( UIMenuViewSceneLighting->value() )
		{
			UIMenuViewSceneLighting->clear();
			UIViewWindow->SetDisplay( ViewState::SCENELIGHT, false );
		}
		else
		{
			UIMenuViewSceneLighting->set();
			UIViewWindow->SetDisplay( ViewState::SCENELIGHT, true );
		}
  	}} {}
  }
  Function {ToggleTextureModel()} {} {
    code {Fl::focus( UIViewWindow );

	if( UIMenuViewModelTexture->active() )
  	{
		if( UIMenuViewModelTexture->value() )
		{
			UIMenuViewModelTexture->clear();
			UIViewWindow->SetDisplay( ViewState::LIGHTING, false );
		}
		else
		{
			UIMenuViewModelTexture->set();
			UIViewWindow->SetDisplay( ViewState::TEXTURE, true );
		}
  	}} {}
  }
  Function {ToggleTextureScene()} {} {
    code {Fl::focus( UIViewWindow );

	if( UIMenuViewSceneTexture->active() )
  	{
		if( UIMenuViewSceneTexture->value() )
		{
			UIMenuViewSceneTexture->clear();
			UIViewWindow->SetDisplay( ViewState::SCENETXT, false );
		}
		else
		{
			UIMenuViewSceneTexture->set();
			UIViewWindow->SetDisplay( ViewState::SCENETXT, true );
		}
  	}} {}
  }
  Function {ResetCam()} {} {
    code {Fl::focus( UIViewWindow );

	UIViewWindow->SetDisplay( ViewState::RESET );} {}
  }
  Function {ToggleCompass()} {} {
    code {Fl::focus( UIViewWindow );

	if( UIMenuViewDisplayCompass->value() )
	{
		UIMenuViewDisplayCompass->clear();
		UIViewWindow->SetDisplay( ViewState::COMPASS, false );
	}
	else
	{
		UIMenuViewDisplayCompass->set();
		UIViewWindow->SetDisplay( ViewState::COMPASS, true );
	}} {}
  }
  Function {ToggleXYPlane()} {} {
    code {Fl::focus( UIViewWindow );

	if( UIMenuViewDisplayXYPlane->value() )
	{
		UIMenuViewDisplayXYPlane->clear();
		UIViewWindow->SetDisplay( ViewState::XY_PLANE, false );
	}
	else
	{
		UIMenuViewDisplayXYPlane->set();
		UIViewWindow->SetDisplay( ViewState::XY_PLANE, true );
	}} {}
  }
  Function {ToggleYZPlane()} {} {
    code {Fl::focus( UIViewWindow );

	if( UIMenuViewDisplayYZPlane->value() )
	{
		UIMenuViewDisplayYZPlane->clear();
		UIViewWindow->SetDisplay( ViewState::YZ_PLANE, false );
	}
	else
	{
		UIMenuViewDisplayYZPlane->set();
		UIViewWindow->SetDisplay( ViewState::YZ_PLANE, true );
	}} {}
  }
  Function {ToggleZXPlane()} {} {
    code {Fl::focus( UIViewWindow );

	if( UIMenuViewDisplayZXPlane->value() )
	{
		UIMenuViewDisplayZXPlane->clear();
		UIViewWindow->SetDisplay( ViewState::ZX_PLANE, false );
	}
	else
	{
		UIMenuViewDisplayZXPlane->set();
		UIViewWindow->SetDisplay( ViewState::ZX_PLANE, true );
	}} {}
  }
} 

class ChoicePopUp {: {public Fl_Choice}
} {
  Function {ChoicePopUp( int nX, int nY, int nW, int nH, const char* pL = 0 ) : Fl_Choice(nX,nY,nW,nH,pL)} {} {
    code {} {}
  }
  Function {InsertFile( std::string szPathFile, ViewWindow* pViewWindow )} {} {
    code {// ::add() will mangle the string so we do an "add/replace"
	int nIndx = Fl_Choice::add( "t" );
	Fl_Choice::replace( nIndx, szPathFile.c_str() );
	Fl_Choice::callback( SelectSCB, pViewWindow );
	Fl_Choice::value( nIndx );

	// call the select callback directly
	// because the ::value() function won't
	SelectCB( pViewWindow );} {}
  }
  Function {SelectSCB( Fl_Widget* pWidget, void* pViewWindow )} {return_type {static void}
  } {
    code {static_cast<ChoicePopUp*>(pWidget)->SelectCB( static_cast<ViewWindow*>(pViewWindow) );} {}
  }
  Function {SelectCB( ViewWindow* pViewWindow )} {} {
    code {if( pViewWindow == NULL )
		return;

	pViewWindow->SelectFile( Fl_Choice::value() );} {}
  }
  Function {SelectFile( int nIndx )} {} {
    code {Fl_Choice::value( nIndx );
	Fl_Choice::damage( FL_DAMAGE_ALL  );} {}
  }
} 
